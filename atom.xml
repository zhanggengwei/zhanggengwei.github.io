<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blogs</title>
  
  <subtitle>张庚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-14T06:47:49.561Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhanggeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音频概述</title>
    <link href="http://yoursite.com/2018/05/14/%E9%9F%B3%E9%A2%91%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/05/14/音频概述/</id>
    <published>2018-05-14T06:35:47.000Z</published>
    <updated>2018-05-14T06:47:49.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="音频简述"><a href="#音频简述" class="headerlink" title="音频简述"></a>音频简述</h2><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>先来简单了解一下一些基础的音频知识。</p><p>目前我们在计算机上进行音频播放都需要依赖于音频文件，音频文件的生成过程是将声音信息采样、量化和编码产生的数字信号的过程，人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。根据奈奎斯特的理论，只有采样频率高于声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。</p><p>对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），简称PCM。PCM数据是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。</p><p>目前最为常用的音频格式是MP3，MP3是一种有损压缩的音频格式，设计这种格式的目的就是为了大幅度的减小音频的数据量，它舍弃PCM音频数据中人类听觉不敏感的部分，从下面的比较图我们可以明显的看到MP3数据相比PCM数据明显矮了一截（图片引自imp3论坛）。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioPcm.jpg?raw=true" alt=""><br>上图为pcm数据<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioMp3.jpg?raw=true" alt=""><br>上图为mp3数据</p><p>MP3格式中的码率（BitRate）代表了MP3数据的压缩质量，现在常用的码率有128kbit/s、160kbit/s、320kbit/s等等，这个值越高声音质量也就越高。MP3编码方式常用的有两种固定码率(Constant bitrate，CBR)和可变码率(Variable bitrate，VBR)。<br>MP3格式中的数据通常由两部分组成，一部分为ID3用来存储歌名、演唱者、专辑、音轨数等信息，另一部分为音频数据。音频数据部分以帧(frame)为单位存储，每个音频都有自己的帧头，如图所示就是一个MP3文件帧结构图（图片同样来自互联网）。MP3中的每一个帧都有自己的帧头，其中存储了采样率等解码必须的信息，所以每一个帧都可以独立于文件存在和播放，这个特性加上高压缩比使得MP3文件成为了音频流播放的主流格式。帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的，对CBR的MP3数据来说每个帧中包含的PCM数据帧是固定的，而VBR是可变的。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/cbr.jpg?raw=true" alt=""></p><h2 id="iOS音频播放概述"><a href="#iOS音频播放概述" class="headerlink" title="iOS音频播放概述"></a>iOS音频播放概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">了解了基础概念之后我们就可以列出一个经典的音频播放流程（以MP3为例）：</span><br><span class="line">1.读取MP3文件</span><br><span class="line">2.解析采样率、码率、时长等信息，分离MP3中的音频帧</span><br><span class="line">3.对分离出来的音频帧解码得到PCM数据</span><br><span class="line">4.对PCM数据进行音效处理（均衡器、混响器等，非必须）</span><br><span class="line">5.把PCM数据解码成音频信号</span><br><span class="line">6.把音频信号交给硬件播放</span><br><span class="line">7.重复1-6步直到播放完成</span><br></pre></td></tr></table></figure><p>在iOS系统中apple对上述的流程进行了封装并提供了不同层次的接口</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audio_service.jpg?raw=true" alt=""><br>CoreAudio的接口层次</p><p>下面对其中的中高层接口进行功能说明：</p><ul><li>Audio File Services：读写音频数据，可以完成播放流程中的第2步；</li><li>Audio File Stream Services：对音频进行解码，可以完成播放流程中的第2步；</li><li>Audio Converter services：音频数据转换，可以完成播放流程中的第3步；</li><li>Audio Processing Graph Services：音效处理模块，可以完成播放流程中的第4步；</li><li>Audio Unit Services：播放音频数据：可以完成播放流程中的第5步、第6步；</li><li>Extended Audio File Services：Audio File Services和Audio Converter services的结合体；</li><li>AVAudioPlayer/AVPlayer(AVFoundation)：高级接口，可以完成整个音频播放的过程（包括本地文件和网络流播放，第4步除外）；</li><li>Audio Queue Services：高级接口，可以进行录音和播放，可以完成播放流程中的第3、5、6步；</li><li>OpenAL：用于游戏音频播放，暂不讨论,可以看到apple提供的接口类型非常丰富，可以满足各种类别类需求：</li><li>如果你只是想实现音频的播放，没有其他需求AVFoundation会很好的满足你的需求。它的接口使用简单、不用关心其中的细节； +         如果你的app需要对音频进行流播放并且同时存储，那么AudioFileStreamer加AudioQueue能够帮到你，你可以先把音频数据下载到本地，一边下载一边用NSFileHandler等接口读取本地音频文件并交给AudioFileStreamer或者AudioFile解析分离音频帧，分离出来的音频帧可以送给AudioQueue进行解码和播放。如果是本地文件直接读取文件解析即可。（这两个都是比较直接的做法，这类需求也可以用AVFoundation+本地server的方式实现，AVAudioPlayer会把请求发送给本地server，由本地server转发出去，获取数据后在本地server中存储并转送给AVAudioPlayer。另一个比较trick的做法是先把音频下载到文件中，在下载到一定量的数据后把文件路径给AVAudioPlayer播放，当然这种做法在音频seek后就回有问题了。）； +     如果你正在开发一个专业的音乐播放软件，需要对音频施加音效（均衡器、混响器），那么除了数据的读取和解析以外还需要用到AudioConverter来把音频数据转换成PCM数据，再由AudioUnit+AUGraph来进行音效处理和播放（但目前多数带音效的app都是自己开发音效模块来坐PCM数据的处理，这部分功能自行开发在自定义性和扩展性上会比较强一些。PCM数据通过音效器处理完成后就可以使用AudioUnit播放了，当然AudioQueue也支持直接使对PCM数据进行播放。）。</li></ul><p>下图描述的就是使用AudioFile + AudioConverter + AudioUnit进行音频播放的流程（图片引自官方文档）<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioUnitPlay.jpg?raw=true" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;音频简述&quot;&gt;&lt;a href=&quot;#音频简述&quot; class=&quot;headerlink&quot; title=&quot;音频简述&quot;&gt;&lt;/a&gt;音频简述&lt;/h2&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>linux文件复用</title>
    <link href="http://yoursite.com/2018/05/14/linux%E6%96%87%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/14/linux文件复用/</id>
    <published>2018-05-14T05:52:56.000Z</published>
    <updated>2018-05-14T06:34:22.771Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自<a href="https://blog.csdn.net/colzer/article/details/8169075" target="_blank" rel="noopener">Linux网络编程</a></p><p># </p><h2 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h2><p>Linux的内核将所有外部设备都可以看做一个文件来操作。那么我们对与外部设备的操作都可以看做对文件进行操作。我们对一个文件的读写，都通过调用内核提供的系统调用；内核给我们返回一个file descriptor（fd,文件描述符）。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符）。描述符就是一个数字，指向内核中一个结构体（文件路径，数据区，等一些属性）。那么我们的应用程序对文件的读写就通过对描述符的读写完成。<br> linux将内存分为内核区，用户区。linux内核给我们管理所有的硬件资源，应用程序通过调用系统调用和内核交互，达到使用硬件资源的目的。应用程序通过系统调用read发起一个读操作，这时候内核创建一个文件描述符，并通过驱动程序向硬件发送读指令，并将读的的数据放在这个描述符对应结构体的内核缓存区中，然后再把这个数据读到用户进程空间中，这样完成了一次读操作；<br>但是大家都知道I/O设备相比cpu的速度是极慢的。linux提供的read系统调用，也是一个阻塞函数。这样我们的应用进程在发起read系统调用时，就必须阻塞，就进程被挂起而等待文件描述符的读就绪，那么什么是文件描述符读就绪，什么是写就绪？<br>读就绪：就是这个文件描述符的接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小；<br>写就绪：该描述符发送缓冲区的可用空间字节数大于等于描述符发送缓冲区低水位标记的当前大小。（如果是socket fd，说明上一个数据已经发送完成）。<br>接收低水位标记和发送低水位标记：由应用程序指定，比如应用程序指定接收低水位为64个字节。那么接收缓冲区有64个字节，才算fd读就绪；<br>综上所述，一个基本的IO，它会涉及到两个系统对象，一个是调用这个IO的进程对象，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过read系统调用想内核发起读请求。</span><br><span class="line">2.内核向硬件发送读指令，并等待读就绪。 </span><br><span class="line">3.内核把将要读取的数据复制到描述符所指向的内核缓存区中。</span><br><span class="line">4.将数据从内核缓存区拷贝到用户进程空间中。</span><br></pre></td></tr></table></figure></p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>在linux系统下面，根据IO操作的是否被阻塞以及同步异步问题进行分类，可以得到下面五种IO模型：</p><h3 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h3><p>最流行的I/O模型是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接口为例来讲解此模型。在进程空间中调用recvfrom，其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回，期间一直在等待。我们就说进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/IO.jpg?raw=true" alt=""></p><h3 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h3><p>进程把一个套接口设置成非阻塞是在通知内核：当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/IO1.jpg?raw=true" alt=""></p><h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p>linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select;这样select/poll可以帮我们侦测许多fd是否就绪。但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描,当有fd就绪时，立即回调函数rollback；<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io3.jpg?raw=true" alt=""></p><h3 id="信号驱动异步I-O模型"><a href="#信号驱动异步I-O模型" class="headerlink" title="信号驱动异步I/O模型"></a>信号驱动异步I/O模型</h3><p>首先开启套接口信号驱动I/O功能, 并通过系统调用sigaction安装一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据报准备好被读时，就为该进程生成一个SIGIO信号。随即可以在信号处理程序中调用recvfrom来读数据报，井通知主循环数据已准备好被处理中。也可以通知主循环，让它来读数据报。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io4.jpg?raw=true" alt=""></p><h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核拷贝到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O：由内核通知我们何时可以启动一个I/O操作；异步I/O模型：由内核通知我们I/O操作何时完成。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io5.jpg?raw=true" alt=""></p><h2 id="非阻塞IO详解"><a href="#非阻塞IO详解" class="headerlink" title="非阻塞IO详解"></a>非阻塞IO详解</h2><p>在IO编程过程中，当需要处理多个请求的时，可以使用多线程和IO复用的方式进行处理。上面的图介绍了整个IO复用的过程，它通过把多个IO的阻塞复用到一个select之类的阻塞上，从而使得系统在单线程的情况下同时支持处理多个请求。和多线程/进程比较，I/O多路复用的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程。IO复用常见的应用场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户程序需要同时处理交互式的输入和服务器之间的网络连接。</span><br><span class="line">客户端需要对多个网络连接作出反应。</span><br><span class="line">服务器需要同时处理多个处于监听状态和多个连接状态的套接字</span><br><span class="line">服务器需要处理多种网络协议的套接字。</span><br></pre></td></tr></table></figure></p><p>目前支持I/O复用的系统调用有select、pselect、poll、epoll，下面几小结分别来学习一下select和epoll的使用。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;  </span><br><span class="line">int select(int maxfdps, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);  </span><br><span class="line">struct timeval&#123;  </span><br><span class="line">   long tv_sec; //秒  </span><br><span class="line">long tv_usec; //微秒  </span><br><span class="line">&#125;;  </span><br><span class="line">void FD_CLR(int fd, fd_set *set); //将一个给定的文件描述符从集合中删除  int  FD_ISSET(int fd, fd_set *set);  // 检查集合中指定的文件描述符是否可以读写 ?  </span><br><span class="line">void FD_SET(int fd, fd_set *set); //将一个给定的文件描述符加入集合之中  </span><br><span class="line">void FD_ZERO(fd_set *set);//清空集合</span><br></pre></td></tr></table></figure><p>struct timeval <em>time结构体告知内核等待所指定描述字中的任何一个就绪可花多少时间。参数取值：<br>（1）(struct timeval </em>)0：永远等待下去，仅在有一个描述字准备好I/O时才返回。<br>（2）struct timeval *time：在有一个描述字准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。如果超过时间，没有描述字准备好，那就返回0。如果秒=微秒=0，检查描述字后立即返回，此时相当于轮询。<br>中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述字。如果我们对某一个的条件不感兴趣，就可以把它设为空指针。fd_set可以理解为一个集合，这个集合中存放的是文件描述符，可通过上面的四个宏进行设置（注意，fd_set不是struct fd_set。。。 刚刚开始调试程序就犯错误，返回storage size of ‘fds’ isn’t known）。<br>第一个参数maxfdp1指定待测试的描述字个数，它的值是待测试的最大描述字加1（因此我们把该参数命名为maxfdp1），描述字0、1、2…maxfdp1-1均将被测试。</p><h3 id="pselect"><a href="#pselect" class="headerlink" title="pselect"></a>pselect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt; </span><br><span class="line"> int pselect(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);  </span><br><span class="line">struct timespec&#123;  </span><br><span class="line">time_t tv_sec; //秒  </span><br><span class="line">long tv_nsec; //纳秒  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较select和pselect函数，我们发现在原型上面有两个不同：<br>1、pselect使用timespec结构，而不使用timeval结构。timespec结构是POSIX的又一个发明。 这两个结构的区别在于第二个成员：新结构的该成员tv_nsec指定纳秒数，而旧结构的该成员tv_usec指定微秒数。<br>2、pselect函数增加了第六个参数：一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置的全局变量，然后调用pselect，告诉它重新设置信号掩码。<br>首先我们看看信号掩码的概念：在POSIX下，每个进程有一个信号掩码(signal mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。为什么对某一信号进行屏蔽呢？我们来看一下对CTRL_C的处理。大家知道，当一个程序正在运行时，在键盘上按一下CTRL_C，内核就会向相应的进程发出一个SIGINT 信号，而对这个信号的默认操作就是通过do_exit()结束该进程的运行。但是，有些应用程序可能对CTRL_C有自己的处理，所以就要为SIGINT另行设置一个处理程序，使它指向应用程序中的一个函数，在那个函数中对CTRL_C这个事件作出响应。但是，在实践中却发现，两次CTRL_C事件往往过于密集，有时候刚刚进入第一个信号的处理程序，第二个SIGINT信号就到达了，而第二个信号的默认操作是杀死进程，这样，第一个信号的处理程序根本没有执行完。为了避免这种情况的出现，就在执行一个信号处理程序的过程中将该种信号自动屏蔽掉。所谓“屏蔽”，与将信号忽略是不同的，它只是将信号暂时“遮盖”一下，一旦屏蔽去掉，已到达的信号又继续得到处理。有关信号相关的知识参考我另外一个文章：<a href="https://blog.csdn.net/colzer/article/details/8135542" target="_blank" rel="noopener">《linux基础编程：进程通信之信号》</a>。在我们开发过程中，如果进程阻塞与select函数，此时该阻塞被信号所打断，select返回-1，errno=EINTR的错误。由于这个原因，我们才有了pselect函数在信号上的优化处理。因此在信号和select都被使用的系统里，pselect有其作用。否则和select没有任何区别。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;    </span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);  </span><br><span class="line">struct pollfd &#123;  </span><br><span class="line">int fd; /* file descriptor */  </span><br><span class="line">short events; </span><br><span class="line">/* requested events to watch */  </span><br><span class="line">short revents; </span><br><span class="line">/* returned events witnessed */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和select()不一样，poll()没有使用低效的三个基于位的文件描述符set，而是采用了一个单独的结构体pollfd数组，由fds指针指向这个数组的第一个元素，其中nfds表示该数组的大小。每一个pollfd 结构体指定了一个被监视的文件描述符，每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码。内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回，而部分事件不能出现在events中，详细如下表。</p><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td>POLLIN</td><td>普通或优先级带数据可读</td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读</td></tr><tr><td>POLLOUT</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td></tr><tr><td>POLLERR</td><td>发生错误</td></tr><tr><td>POLLHUP</td><td>发生挂起</td></tr><tr><td>POLLNVAL</td><td>描述字不是一个打开的文件</td></tr></tbody></table> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：后三个只能作为描述字的返回结果存储在revents中，而不能作为测试条件用于events中。</span><br></pre></td></tr></table></figure><p> 最后一个参数timeout是指定poll函数返回前等待多长时间。它的取值如下：</p><table><thead><tr><th>timeout值</th><th>说明</th></tr></thead><tbody><tr><td>INFTIM</td><td>永远等待</td></tr><tr><td>0</td><td>立即返回，不阻塞进程</td></tr><tr><td>＞0</td><td>等待指定数目的毫秒数</td></tr></tbody></table><p> 成功时，poll()返回结构体中revents域不为0的文件描述符个数；如果在超时前没有任何事件发生，poll()返回0；失败时，poll()返回-1，并设置errno为下列值之一：<br>EBADF：一个或多个结构体中指定的文件描述符无效。EFAULT：fds指针指向的地址超出进程的地址空间。EINTR：请求的事件之前产生一个信号，调用可以重新发起。EINVAL：nfds参数超出PLIMIT_NOFILE值。ENOMEM：可用内存不足，无法完成请求。<br>关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client[0].fd = listenfd;         /*将数组中的第一个元素设置成监听描述字*/  </span><br><span class="line">client[0].events = POLLIN;    </span><br><span class="line">while(1)  &#123;  </span><br><span class="line">nready = poll(client, maxi+1,INFTIM); //将进程阻塞在poll上  </span><br><span class="line">if( client[0].revents &amp; POLLIN/*POLLRDNORM*/ ) </span><br><span class="line">/*先测试监听描述字*/</span><br></pre></td></tr></table></figure><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>在linux的网络编程中，很长的一段时间都在使用select来做事件触发。然而select逐渐暴露出了一些缺陷，使得linux不得不在新的内核中寻找出替代方案，那就是epoll。其实，epoll与select原理类似，只不过，epoll作出了一些重大改进，即：<br>1.支持一个进程打开大数目的socket描述符(FD)<br>select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。<br>2.IO效率不随FD数目增加而线性下降<br>传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。<br>3.使用mmap加速内核与用户空间的消息传递。<br>这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。<br>4.内核微调<br>这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 — 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。</p><p>epoll api函数比较简单，包括创建一个epoll描述符，添加监听事件，阻塞等待所监听的事件发生,关闭epoll描述符，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">int epoll_create(int size); </span><br><span class="line">//epoll描述符  </span><br><span class="line">int close(int fd);//关闭epoll描述符</span><br></pre></td></tr></table></figure><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。需要注意的是，当创建好epoll句柄后，epoll本身就占用一个fd值，所以用完后必须调用close()关闭，以防止fd被耗尽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;    </span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//添加监听事件  </span><br><span class="line">  </span><br><span class="line">typedef union epoll_data &#123;  </span><br><span class="line">  void  *ptr;  </span><br><span class="line">  int   fd;  </span><br><span class="line">  uint32_t  u32;  </span><br><span class="line">  uint64_t  u64;  </span><br><span class="line">&#125; epoll_data_t;  </span><br><span class="line">  </span><br><span class="line">struct epoll_event &#123;  </span><br><span class="line">   uint32_t events;     </span><br><span class="line">   /* Epoll events */  </span><br><span class="line">   epoll_data_t data;        </span><br><span class="line">   /* User data variable */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>epoll_ctl为事件注册函数，第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从epfd中删除一个fd;<br>第三个参数是需要监听的描述符fd,第四个参数是告诉内核需要监听什么事件，struct epoll_event结构如上所示，其中events为需要注册的事件，可以为下面几个宏的集合：</li><li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET：将EPOLL设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。详细见下面描述</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li></ul><p>操作系统对被注册的文件描述符的事件发送以后有两种处理方式，分别有LT和ET模式，默认情况下为LT，如果需要设置为ET模式，设置struct epoll_event.events|EPOLLET。</p><ul><li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点，传统的select/poll都是这种模型的代表。</li><li>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</li></ul><p>struct epoll_event.data为一个epoll_data_t类型的联合体，详细结构如上，其中可以保存指针，描述符，32/64位的整数。如果在监听过程中，该描述符上面有相应的事件发生，系统将会把该字段返回。先看监听函数吧。看完就知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);//阻塞等待所监听的事件发生</span><br></pre></td></tr></table></figure><p>阻塞监听函数，类似于select()调用。参数events用来从内核得到事件的集合，返回的结构也是struct epoll_event，其中event为相应的事件，data为注册时，设置的值（常见情况，data设置为注册的描述符，这样就可以对相应的描述符进行IO操作）。maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><p>最后我们说一下，用来克服select/poll缺点的方法不只有epoll。epoll只是一种linux 的方案，在freeBSD下有kqueue，而dev/poll 是最古老的Solaris的方案，使用难度依次递增。 kqueue 是freebsd 的宠儿，kqueue 实际上是一个功能相当丰富的kernel 事件队列，它不仅仅是select/poll 的升级，而且可以处理 signal 、目录结构变化、进程等多种事件。Kqueue 是边缘触发的。/dev/poll 是Solaris的产物，是这一系列高性能API 中最早出现的。Kernel 提供一个特殊的设备文件/dev/poll 。应用程序打开这个文件得到操纵fd_set 的句柄，通过写入pollfd 来修改它，一个特殊ioctl 调用用来替换select 。由于出现的年代比较早，所以/dev/poll 的接口现在看上去比较笨拙可笑。</p><h2 id="信号驱动异步IO详解"><a href="#信号驱动异步IO详解" class="headerlink" title="信号驱动异步IO详解"></a>信号驱动异步IO详解</h2><p>上面介绍了不管是阻塞/非阻塞或者IO复用，在应用程序层面都需要进行阻塞轮询指定的IO上面是否有相应的事件发生。本节我们将将介绍一个全新的模型：异步模型，异步则意味着不需要用户层进行轮询，在特定IO或者事件发生时候，会主动通知应用程序IO就绪，本节介绍的通知机制即信号，我们把这个模型叫着信号驱动的异步I/O。在《linux基础编程：进程通信之信号》文章中，我们详细介绍信号操作。<br>Unix上有定义了许多信号，源自Berkeley的实现使用的是SIGIO信号来支持套接字和终端设备上的信号驱动IO。在套接字IO中，信号驱动IO模型主要是在UDP套接字上使用，在TCP套接字上几乎是没有什么使用的（在TCP上，由于TCP是双工的，它的信号产生过于平凡，并且信号的出现几乎没有告诉我们发生了什么事情。因此对于TCP套接字，SIGIO信号是没有什么使用的）。<br>使用信号驱动异步IO主要有下面几个步骤：<br>为了让套接字描述符可以工作于信号驱动I/O模式，应用进程必须完成如下三步设置： </p><ul><li>1.注册SIGIO信号处理程序。(安装信号处理器) </li><li>2.使用fcntl的F_SETOWN命令，设置套接字所有者。 </li><li>3.使用fcntl的F_SETFL命令，置O_ASYNC和O_NONBLOCK标志，允许套接字信号驱动I/O。</li></ul><p>注意，必须保证在设置套接字所有者之前，向系统注册信号处理程序，否则就有可能在fcntl调用后，信号处理程序注册前内核向应用交付SIGIO信号，导致应用丢失此信号。<br>代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction sigio_action;  </span><br><span class="line">memset(&amp;sigio_action, 0, sizeof(sigio_action));  </span><br><span class="line">sigio_action.sa_flags = 0;  </span><br><span class="line">sigio_action.sa_handler = do_sigio;</span><br><span class="line">//信号发生时的处理函数  </span><br><span class="line">sigaction(SIGIO, &amp;sigio_action, NULL);  </span><br><span class="line">fcntl(listenfd1, F_SETOWN, getpid());  </span><br><span class="line">int flags;  </span><br><span class="line">flags = fcntl(listenfd1, F_GETFL, 0);  </span><br><span class="line">flags |= O_ASYNC | O_NONBLOCK;  </span><br><span class="line">fcntl(listenfd1, F_SETFL, flags);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自&lt;a href=&quot;https://blog.csdn.net/colzer/article/details/8169075&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux网络编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;IO概
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>RunLoop-事件循环对象</title>
    <link href="http://yoursite.com/2018/05/14/RunLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/05/14/RunLoop-事件循环对象/</id>
    <published>2018-05-14T02:50:58.000Z</published>
    <updated>2018-05-14T05:48:11.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop-的基本概念"><a href="#RunLoop-的基本概念" class="headerlink" title="RunLoop 的基本概念"></a>RunLoop 的基本概念</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1、runloop是什么-————-O"><a href="#1、runloop是什么-————-O" class="headerlink" title="1、runloop是什么? ———— O"></a>1、runloop是什么? ———— O</h4><p>   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比<br> 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：do {//接受消息-&gt;等待-&gt;处理}while(message != quit)线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结&gt; 束（比如传入 quit 的<br>消息），函数返回。</p><h4 id="没有runloop会怎样？"><a href="#没有runloop会怎样？" class="headerlink" title="没有runloop会怎样？"></a>没有runloop会怎样？</h4><p>上面这样的运行机制通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，<br>比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。<br>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>如果iOS APP 没有runloop 机制会怎么样呢？<br>如果没有runloop的机制的话，我们的app，从一启动到退出程序时间会很短。<br>更加形象的说，app一启动就死了。<br>所以，runloop 的存在，就是保住app的生命，让app 可以随时待命，处理用户的操作以及其他事件。<br>runloop的重要性就在于：我们控制了runloop ,就是控制了app 的生死</p><h2 id="RunLoop-相关类以及构成要素"><a href="#RunLoop-相关类以及构成要素" class="headerlink" title="RunLoop 相关类以及构成要素"></a>RunLoop 相关类以及构成要素</h2><h3 id="runloop-相关类"><a href="#runloop-相关类" class="headerlink" title="runloop 相关类"></a>runloop 相关类</h3><p>在 iOS 中，RunLoop 就是个对象。<br>众所周知，OC 语言是对于 C 的封装。所以呢，会有两个框架，一个是 CoreFoundation，一个是面向对象的 Foundation。<br>全文在解释原理的时候，是直接使用底层 CoreFoundation 的源码解释。</p><p>在 CoreFoundation 框架为 CFRunLoopRef 对象，它提供了纯 C 函数的 API，并且这些 API 是线程安全的；<br>而在 Foundation 框架中用 NSRunLoop 对象来表示，它是基于 CFRunLoopRef 的封装，提供的是面向对象的 API，但这些 API 不是线程安全的。<br>CFRunLoopRef 的代码是开源的，我们可以在 这里 或 这里 找到 CFRunLoop.c 来查看 RunLoop 的源码。</p><h3 id="构成元素"><a href="#构成元素" class="headerlink" title="构成元素"></a>构成元素</h3><p>在 CoreFoundation 中关于 RunLoop 有 5 个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure><p>一个Runloop对应一条线程，一个runloop里面可以有多个CFRunLoopModeRef(模式）。<br>同一个时刻，RunLoop只能是在一个mode上面的运行。如果需要切换mode,只能是退出currentMode ,切换到指定的 mode 。<br>每一个mode又可以包含多个 source/timer/observer。不同 mode 里面的子元素，互不影响。</p><p>5个类的对应关系大概是：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop.png?raw=true" alt=""></p><p>下面具体介绍这个CFRunLoop里面的4个类。</p><h4 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h4><p>官方文档介绍如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified.</span><br><span class="line">You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.</span><br><span class="line">You use modes to filter out events from unwanted sources during a particular pass through your run loop.</span><br></pre></td></tr></table></figure></p><p>即一个 run loop mode 是若干个 source、timer 和 observer 的集合。它能帮我们过滤掉一些不想要的事件。</p><p>即一个 RunLoop 在某个 mode 下运行时，不会接收和处理其他 mode 的事件 </p><p>要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer 。</p><p>这一点很容易理解，你想啊，如果一个 mode 里面什么东西都没有，那么他根本就没有活干，那 mode 活着还有什么意思。</p><p>苹果公开的 mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode。</p><p>前者是默认的模式，程序运行的大多时候都处于该 mode 下，后者是滑动 tableView 或 scrollerView 时为了界面流畅而用的 mode。</p><p>还有个 UIInitializationRunLoopMode 是程序启动时进入的 mode，一般用不上。<br>以上，两个公开常用的 mode, 在执行的时候，相互独立，互不干扰。</p><p>这样让不同的mode各司其职，对于程序运行的解耦很有好处。<br>但是如果偏偏想要让两个互相不干扰的mode,都做同一件事情可以实现么？<br>可以实现的。苹果爸爸，想到了这一点。<br>CFRunLoop里面有一个伪mode叫做 kCFRunLoopCommonModes，它不是一个真正的 mode，而是若干个 mode 的集合。<br>你可以把这个 kCFRunLoopCommonModes 理解成：折磨你改需求的产品经理。<br>kCFRunLoopDefaultMode 就是写android的程序员，UITrackingRunLoopMode是写iOS的程序员。<br>产品经理一个需求，两个程序员必须都要实现这个功能。<br>我们往 CommonModes 里面加入 任意的 source/timer/observer 。<br>就可以想象成是产品经理有新的需求。Android 和 iOS 程序员都要把需求实现。<br>只要加入到了 CommonModes 里面，就相当于添加到了它里面所有的 mode 中（当然，根据各自的情况，可能不仅仅只要默认的两个 mode ）。<br>我们可以通过 NSLog(@”%@”, [NSRunLoop currentRunLoop]) 从打印结果看到 CommonMode 包含了上面的 DefaultMode 和 TrackingRunLoopMode。</p><blockquote><pre><code>common modes = &lt;CFBasicHash 0x7fdaa0d00ae0 [0x1084b57b0]&gt;{type = mutable set, count = 2, entries =&gt;0 : &lt;CFString 0x10939f950 [0x1084b57b0]&gt;{contents = “UITrackingRunLoopMode”}2 : &lt;CFString 0x1084d5b40 [0x1084b57b0]&gt;{contents = “kCFRunLoopDefaultMode”}}</code></pre></blockquote><h4 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h4><p>source 是事件产生的地方（输入源），虽然官方文档在概念上把 source 分为三类：Port-Based Sources，Custom Input Sources，Cocoa Perform Selector Sources。<br>但在源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。<br>source0 是app内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。<br>source1 是基于 mach_ports 的，用于通过内核和其他线程互相发送消息。<br>iOS / OSX 都是基于 Mach 内核，Mach 的对象间的通信是通过消息在两个端口(port)之间传递来完成。<br>很多时候我们的 app 都是处于什么事都不干的状态，在空闲前指定用于唤醒的 mach port 端口，然后在空闲时被 mach_msg() 函数阻塞着并监听唤醒端口， mach_msg() 又会调用 mach_msg_trap() 函数从用户态切换到内核态，这样系统内核就将这个线程挂起，一直停留在 mac_msg_trap 状态。直到另一个线程向内核发送这个端口的 msg 后， trap 状态被唤醒， RunLoop 继续开始干活。<br>其实，总结下来，事件产生的地方就是source(输入源), 运用发消息的机制，让事件可以唤醒休眠的runloop执行。</p><h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>看到 timer 是不是很熟悉？<br>这里的 timer 看起来名字是用C语言的样式，其实是完全等价于我们在OC里面的计时器NSTimer。<br>所以，在平时编程的过程中，我们最开始意识到有 runloop 这回事，就是了使用 NSTimer 的时候。这一点在后面的具体场景应用会详细提到的。<br>另外，这个 CFRunLoopTimerRef，还可以由方法 performSelector:afterDelay:来触发。（因为，本质上 afterDelay, 底层就是启动了 timer ,不然怎么检测具体时间，然后调用回调方法呢。）</p><h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p>看到名字就应该知道这就是一个观察者。它的主要用途就是监听 RunLoop 的状态变化。</p><p>它可以监听RunLoop的7种状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ Run Loop Observer Activities /</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">// 即将进入 loop kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">// 即将处理 timer kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">// 即将处理 source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">// 即将 sleep kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">// 刚被唤醒，退出 sleep kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">// 即将退出 kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">// 全部的活动 kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><h3 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h3><p>苹果官方对于 RunLoop 的创建进行了封装，也就是说我们找不到像alloc 或者 new 这样的方法去手动创建RunLoop。<br>要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数。<br>获取过程大概是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">    static CFMutableDictionaryRef __CFRunLoops = NULL;</span><br><span class="line"></span><br><span class="line">    CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    // 第一次进入时，创建全局 dictionary</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        // 创建可变字典</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable();</span><br><span class="line">        // 先创建主线程的 RunLoop</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        // 主线程的 RunLoop 存进字典中</span><br><span class="line">        CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用 传进来的线程 作 key，获取对应的 RunLoop</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(__CFRunLoops, t);</span><br><span class="line"></span><br><span class="line">    // 如果获取不到，则新建一个，并存入字典</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取主线程的 RunLoop</span><br><span class="line">    CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np());</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 RunLoop</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出, runloop 和 pthread_t （也就是线程）是一一对应的。<br>这样一一对应的关系是保存在一个全局的 dictionary 中的。<br>内部产生 runloop 的机制，与我们 iOS 开发中常用的懒加载很相似。<br>只有到了第一次要使用的时候，才回去创建。当线程销毁的时候，也销毁相应的 runloop。</p><h3 id="runloop-运行逻辑"><a href="#runloop-运行逻辑" class="headerlink" title="runloop 运行逻辑"></a>runloop 运行逻辑</h3><p>runloop 整个的运行逻辑都是在于三个重要的对象如何运作：source （输入源）、timer （定时器）、observer (观察者)。<br>上面的关于 runloop 的相关类里面有过介绍，observer 时刻监听，整个 runloop 的7种 状态的变化。<br>在上面 7 种状态里面，对应着不同的处理。<br>网上的参考逻辑图如下<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"> //用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"></span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里 runloop 的整个运行逻辑就是一个 do-while 循环。<br>就是我们开篇说的一个——圈。<br>一旦调用了 CFRunLoopRun ,线程就会一直停留在这个循环里面；只有当超时或者被手动停止，函数才会返回，也就是退出了当前的 runloop 。<br>总结成一句话就是：runloop 的运行逻辑就是 do-while 循环下运用观察者模式（或者说是消息发送），根据7种状态的变化，处理事件输入源和定时器。</p><h2 id="苹果官方-RunLoop-实际应用"><a href="#苹果官方-RunLoop-实际应用" class="headerlink" title="苹果官方 RunLoop 实际应用"></a>苹果官方 RunLoop 实际应用</h2><p>RunLoop 作为 iOS app 底层最重要的运行机制，基本运用在一个APP构成的方方方面。 下面请大家跟我一起来看看，说起来那么晕头转向的 RunLoop, 到底可以解释那些 iOS 的常见机制。<br>先来看一道面试题吧（这是我刚开始工作是一个 JAVA面试官问的）：<br>请问 iOS 的NSAutoreleasePool（自动释放池）在什么时候释放？<br>我当时的很纳闷，难道不是到了@autorelease 的 ‘}’（反大括号）就释放了。<br>相对正确的答案应该是：退出 runloop 之前释放。<br>这样就引出了 RunLoop 的第一个应用—— 自动释放池。</p><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>这里的举例分析的是 APP 启动的时候，与主线程同时生成的自动释放池<br>在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0x1, callout = </span><br><span class="line">_wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br></pre></td></tr></table></figure><p>APP 启动之后，苹果在主线程对应的 RunLoop 里面注册了两个 Observer, 其回调都是<br>_wrapRunLoopWithAutoreleasePoolHandler（）。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。<br>与主线程的 RunLoop 运行逻辑类似，在程序中自定义的自动释放池，也是在即将退出 RunLoop 的时候，释放创建的自动释放池。</p><h3 id="NSTimer-定时器"><a href="#NSTimer-定时器" class="headerlink" title="NSTimer (定时器)"></a>NSTimer (定时器)</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。<br>上面有讲到 RunLoop 本身就是一个圈。更进一步说：不断地围着圈跑。<br>这个特性，很像城市里环城巴士。<br>一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。<br>例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。<br>Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。<br>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h3 id="PerformSelecter…"><a href="#PerformSelecter…" class="headerlink" title="PerformSelecter…"></a>PerformSelecter…</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。<br>这个过程的详细情况可以参考这里。<br>SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。<br>随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。<br>随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h3><p>在当前 RunLoop 的打印结果我们还可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver &gt;&#123;activities = 0xa0,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br></pre></td></tr></table></figure><p>即准备进入睡眠和即将退出 loop 两个时间点，会调用函数更新 UI 界面.<br>当在操作 UI 时，某个需要变化的 UIView/CALayer 就被标记为待处理，然后被提交到一个全局的容器去，再在上面的回调执行时才会被取出来进行绘制和调整。<br>所以如果在一次运行循环中想用如下方法设置一个 view 的两条移动路径是行不通的。因为它会把视图的属性变化汇总起来，直接让 myView 从起点移动到终点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.myView.frame;</span><br><span class="line">// 先向下移动</span><br><span class="line">frame.origin.y += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 再向右移动</span><br><span class="line">frame.origin.x += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在仔细分析一下，上面代码的逻辑。<br>第一个动画是想要做到用1秒的时间，Y 值增加200。第二个动画想要实现的是用1秒的时间，X 值增加200.<br>想要实现的先下后右。<br>但是这样是无法实现的。因为，UI的绘制是拿到所有之后，在统一绘制的。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。如当调用了 dispatch_async(dispatch_get_main_queue(), block)时，主队列会把该 block 放到对应的线程（恰好是主线程）中，主线程的 RunLoop 会被唤醒，从消息中取得这个 block，回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 来执行这个 block：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gcd.png?raw=true" alt=""></p><h2 id="第三方库-RunLoop-的运用"><a href="#第三方库-RunLoop-的运用" class="headerlink" title="第三方库 RunLoop 的运用"></a>第三方库 RunLoop 的运用</h2><h3 id="AFNetWorking-里面的常驻线程"><a href="#AFNetWorking-里面的常驻线程" class="headerlink" title="AFNetWorking 里面的常驻线程"></a>AFNetWorking 里面的常驻线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。</span><br><span class="line">这一点充分体现了：我们控制了runloop ,就是控制了app 的生死。</span><br><span class="line">具体做法是：</span><br><span class="line">            /* 返回一个线程 */</span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">        static NSThread *_networkRequestThread = nil;</span><br><span class="line">        static dispatch_once_t oncePredicate;</span><br><span class="line">        dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">            // 创建一个线程，并在该线程上执行下一个方法</span><br><span class="line">            _networkRequestThread = [[NSThread alloc] initWithTarget:self</span><br><span class="line">                                                            selector:@selector(networkRequestThreadEntryPoint:)</span><br><span class="line">                                                              object:nil];</span><br><span class="line">            // 开启线程</span><br><span class="line">            [_networkRequestThread start];</span><br><span class="line">        &#125;);</span><br><span class="line">        return _networkRequestThread;</span><br><span class="line">    &#125;</span><br><span class="line">/* 在新开的线程中执行的第一个方法 */</span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        // 获取当前线程对应的 RunLoop</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        // 为 RunLoop 添加 source，模式为 DefaultMode</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        // 开始运行 RunLoop</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：<br>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。<br>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。<br>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。<br>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><h2 id="开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"><a href="#开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）" class="headerlink" title="开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"></a>开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）</h2><h3 id="UIImageView-延迟加载图片"><a href="#UIImageView-延迟加载图片" class="headerlink" title="UIImageView 延迟加载图片"></a>UIImageView 延迟加载图片</h3><p>假设我们有一个UITableView，UITableView上面有很多UITableViewCell，UITableViewCell上面有一个UIImageView（你可以想象QQ的聊天页面）。这时候一般我们的需求都是那个UIImageView的图片需要你从网络上下载，并且异步，下载成功之后更新到UIImageView上。<br>实际上这个时候我们就会碰到问题，因为我们的UITab leView是可以任意拖动的，所以如果不更改NSURLConnection的运行模式，那么只要 UItableView 出现滑动，NSURLConnection 所在的DefaultMode 就会退出，切换到 UITrackingRunLoopMode 。<br>给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。<br>解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。<br>为了流畅性，把图片加载延迟</p><h3 id="UITableView-与-NSTimer-冲突"><a href="#UITableView-与-NSTimer-冲突" class="headerlink" title="UITableView 与 NSTimer 冲突"></a>UITableView 与 NSTimer 冲突</h3><p>由于 UItabelView 在滑动的时候，会从当前的 RunLoop 默认的模式 kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 退出，进入到 UITrackingRunLoopMode。<br>这个时候，处于 NSDefaultRunLoopMode 里面的 NSTimer 由于切换了模式造成计时器无法继续运行。<br>可以两个解决方法：（目的就是：即使 mode 切换，计时器依然工作）</p><p>此处参考：<a href="https://www.jianshu.com/p/024782defe60" target="_blank" rel="noopener">iOS下RunLoop的实际应用场景探究</a></p><h2 id="RunLoop-可能的面试套路"><a href="#RunLoop-可能的面试套路" class="headerlink" title="RunLoop 可能的面试套路"></a>RunLoop 可能的面试套路</h2><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop?"></a>什么是RunLoop?</h3><p><a href="http://ios.jobbole.com/85635/" target="_blank" rel="noopener">RunLoop面试题总结</a></p><p>从字面上看:运行循环、跑圈<br>其实它内部就是do-while循环,在这个循环内部不断的处理各种任务(比如Source、Timer、Observer)<br>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop需要手动启动(调用run方法) RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Soure、Timer、Observer,那么就直接退出RunLoop<br>在开发中如何使用RunLoop?什么应用场景?<br>    开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<br>    在子线程中开启一个定时器<br>    在子线程中进行一些长期监控<br>可以控制定时器在特定模式下执行 可以让某些事件(行为、任务)在特定模式下执行 可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RunLoop&quot;&gt;&lt;a href=&quot;#RunLoop&quot; class=&quot;headerlink&quot; title=&quot;RunLoop&quot;&gt;&lt;/a&gt;RunLoop&lt;/h1&gt;&lt;h2 id=&quot;RunLoop-的基本概念&quot;&gt;&lt;a href=&quot;#RunLoop-的基本概念&quot; class
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>position</title>
    <link href="http://yoursite.com/2018/05/14/position%E4%B8%8Eindex-z/"/>
    <id>http://yoursite.com/2018/05/14/position与index-z/</id>
    <published>2018-05-14T01:47:48.000Z</published>
    <updated>2018-05-14T02:47:46.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解css中position属性及z-index属性"><a href="#深入理解css中position属性及z-index属性" class="headerlink" title="深入理解css中position属性及z-index属性"></a>深入理解css中position属性及z-index属性</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在网页设计中，position属性的使用是非常重要的。有时如果不能认识清楚这个属性，将会给我们带来很多意想不到的困难。</span><br><span class="line">　　position属性共有四种不同的定位方法，分别是static、fixed、relative、absolute,sticky。最后将会介绍和position属性密切相关的z-index属性。</span><br></pre></td></tr></table></figure><h2 id="position-static"><a href="#position-static" class="headerlink" title="position:static"></a>position:static</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static定位是HTML元素的默认值，即没有定位，元素出现在正常的流中，因此，这种定位就不会收到top，bottom,left,right的影响。</span><br></pre></td></tr></table></figure><p>html 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&apos;background-color:red;</span><br><span class="line">   width:100px;</span><br><span class="line">height:100px;&apos;&gt;</span><br><span class="line">    &lt;div style=&apos;background-color:green;</span><br><span class="line">width:30px;</span><br><span class="line">height:30px;left:30px&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>效果图如下</p><div style="background-color:red;   width:100px;height:100px;"><br>    <div style="background-color:green;width:30px;height:30px;left:30px"></div><br></div><p>我们发现，虽然设置了static以及top，但是元素仍然出现在正常的流中。</p><h2 id="fixed定位"><a href="#fixed定位" class="headerlink" title="fixed定位"></a>fixed定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与文档流无关，因此不占据空间，且它会和其他元素发生重叠。</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-fixed.png?raw=true" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;我是使用fix来定位的！！！所以我相对于浏览器窗口，一直不动。&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body&#123;height:1500px; background: green; font-size: 30px; color:white;&#125;.content&#123; position: fixed; right:0;bottom: 0; width: 300px;height: 300px; background: blue;&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：fixed定位在IE7和IE8下需要描述！DOCTYPE才能支持。</p><h2 id="relative定位"><a href="#relative定位" class="headerlink" title="relative定位"></a>relative定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相对定位元素的定位是相对它自己的正常位置的定位。</span><br></pre></td></tr></table></figure><p>关键：如何理解其自身的坐标呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;正常位置&lt;/h2&gt;</span><br><span class="line">    &lt;h2 style=&quot;position: relative;top: 300px&quot;&gt;正常位置向下移动&lt;/h2&gt;</span><br><span class="line">    &lt;h2 style=&quot;position: relative;left: 30px;&quot;&gt;正常位置向右移动&lt;/h2&gt;</span><br><span class="line">    即top:300px;；向下移动。  left:50px;向右移动。</span><br></pre></td></tr></table></figure><p>即可以理解为：移动后是移动前的负的位置。<br>移动后是移动前负的bottom:-20px;即移动后是移动前bottom:20px;也就是说，移动后是移动前的向下20px；<br>又如：left:50px;移动后是移动前左边的-50px;那么也就是说移动后是移动前的右边的50px。<br>即：移动后对于移动前：如果值为负数，则直接换成整数；如果值为整数，则直接改变相对方向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">即使相对定位元素的内容是移动,预留空间的元素仍保存在正常流动</span><br><span class="line">即使相对元素的内容移动了，但是预留空间的元素仍然保存在正常流动，也就是说相对移动之后，不会对下面的其他元素造成影响</span><br></pre></td></tr></table></figure><h2 id="absolute定位"><a href="#absolute定位" class="headerlink" title="absolute定位"></a>absolute定位</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">绝对定位的元素相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;绝对定位&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;          </span><br><span class="line">    body&#123;</span><br><span class="line">      background:green;</span><br><span class="line">    &#125;</span><br><span class="line">   .parent&#123; </span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 500px;</span><br><span class="line">      background: #ccc;</span><br><span class="line">   &#125;</span><br><span class="line">   .son&#123; </span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      background: #aaa;</span><br><span class="line">   &#125;</span><br><span class="line">   span&#123;</span><br><span class="line">      position: absolute; </span><br><span class="line">      right: 30px; </span><br><span class="line">      background: #888;</span><br><span class="line">   &#125;</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;son&quot;&gt;</span><br><span class="line">            &lt;span&gt;什么？&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-absolute.png?raw=true" alt=""></p><p>例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.son&#123;position: relative; width: 100px;height: 100px;background: #aaa; &#125;</span><br></pre></td></tr></table></figure><p>相较于上一个例子，我只修改了class为son的元素的css，设置为position：relative；效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-absolute2.png?raw=true" alt=""></p><p>例三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;position: absolute; width: 300px;height: 300px;background: #ccc;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-absolute3.png?raw=true" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当某个absolute定位元素的父元素具有position:relative/absolute/fixed时，定位元素都会依据父元素而定位，而父元素没有设置position属性或者设置了默认属性，那么定位属性会依据html元素来定位。</span><br></pre></td></tr></table></figure></p><h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>我们知道如果使用position:absolute和position:fixed都会导致元素脱离文档流，由此就会产生相应的问题。举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;position&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding:20px;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-11?raw=true" alt=""></p><p>但是一旦子元素的position为fixed或者是absolute，那么它就会脱离文档流，这样的后果是父元素无法被撑开，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;position&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .div1&#123;</span><br><span class="line">            background-color: red;</span><br><span class="line">            padding:20px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .div2&#123;</span><br><span class="line">            position: absolute; // 添加position:absolute使其脱离文档流</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background-color: blue;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;div1&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;div2&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/position-12?raw=true" alt=""></p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解决方法1：在js中设置父元素高度等于子元素的高度。</span><br><span class="line">解决方法2：给父元素强行设置高度。（对于宽度导致的类似问题就强行设置宽度）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解css中position属性及z-index属性&quot;&gt;&lt;a href=&quot;#深入理解css中position属性及z-index属性&quot; class=&quot;headerlink&quot; title=&quot;深入理解css中position属性及z-index属性&quot;&gt;&lt;/a&gt;深入
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-Browser</title>
    <link href="http://yoursite.com/2018/05/11/javascript-Browser/"/>
    <id>http://yoursite.com/2018/05/11/javascript-Browser/</id>
    <published>2018-05-11T06:34:43.000Z</published>
    <updated>2018-05-11T08:34:46.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Window-对象"><a href="#Window-对象" class="headerlink" title="Window 对象"></a>Window 对象</h1><h2 id="Window-对象-1"><a href="#Window-对象-1" class="headerlink" title="Window 对象"></a>Window 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Window 对象表示浏览器中打开的窗口。</span><br><span class="line">如果文档包含框架（&lt;frame&gt; 或 &lt;iframe&gt; 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。</span><br><span class="line">注意： 没有应用于 window 对象的公开标准，不过所有浏览器都支持该对象。</span><br></pre></td></tr></table></figure><h2 id="Window-对象属性"><a href="#Window-对象属性" class="headerlink" title="Window 对象属性"></a>Window 对象属性</h2><h2 id="Window-对象方法"><a href="#Window-对象方法" class="headerlink" title="Window 对象方法"></a>Window 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="#alert">alert()</a></td><td>显示带有一段消息和一个确认按钮的警告框。</td></tr><tr><td><a href="#blur">blur()</a></td><td>把键盘焦点从顶层窗口移开。</td></tr><tr><td><a href="#clearInterval">clearInterval()</a></td><td>取消由 setInterval() 设置的 timeout。</td></tr><tr><td><a href="#clearTimeout">clearTimeout()</a></td><td>取消由 setTimeout() 方法设置的 timeout。</td></tr><tr><td><a href="#close">close()</a></td><td>关闭浏览器窗口。</td></tr><tr><td><a href="#confirm">confirm()</a></td><td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td></tr><tr><td><a href="#createPopup">createPopup()</a></td><td>创建一个 pop-up 窗口。(只有IE支持)</td></tr><tr><td><a href="#focus">focus()</a></td><td>把键盘焦点给予一个窗口</td></tr><tr><td><a href="#moveBy">moveBy()</a></td><td>可相对窗口的当前坐标把它移动指定的像素。</td></tr><tr><td><a href="#moveTo">moveTo()</a></td><td>把窗口的左上角移动到一个指定的坐标。</td></tr><tr><td><a href="#open">open()</a></td><td>打开一个新的浏览器窗口或查找一个已命名的窗口。</td></tr><tr><td><a href="#print">print()</a></td><td>打印当前窗口的内容。</td></tr><tr><td><a href="#prompt">prompt()</a></td><td>显示可提示用户输入的对话框。</td></tr><tr><td><a href="#resizeBy">resizeBy()</a></td><td>按照指定的像素调整窗口的大小。</td></tr><tr><td><a href="#resizeTo">resizeTo()</a></td><td>把窗口的大小调整到指定的宽度和高度。</td></tr><tr><td><a href="#scrollBy">scrollBy()</a></td><td>按照指定的像素值来滚动内容</td></tr><tr><td><a href="#scrollTo">scrollTo()</a></td><td>把内容滚动到指定的坐标。</td></tr><tr><td><a href="#setInterval">setInterval()</a></td><td>按照指定的周期（以毫秒计）来调用函数或计算表达式</td></tr><tr><td><a href="#setTimeout">setTimeout()</a></td><td>在指定的毫秒数后调用函数或计算表达式。</td></tr></tbody></table><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h4><div id=""></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(message)</span><br></pre></td></tr></table></figure><h4 id="blur"><a href="#blur" class="headerlink" title="blur"></a>blur</h4><div id="blur"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.blur()</span><br></pre></td></tr></table></figure><h4 id="clearInterval"><a href="#clearInterval" class="headerlink" title="clearInterval()"></a>clearInterval()</h4><div id="clearInterval"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clearInterval(id_of_setinterval)</span><br><span class="line">id_of_setinterval 调用 setInterval() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setInterval() 所设定的定时执行操作。</span><br></pre></td></tr></table></figure><h4 id="clearTimeout"><a href="#clearTimeout" class="headerlink" title="clearTimeout()"></a>clearTimeout()</h4><div id="clearTimeout"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clearTimeout(id_of_settimeout)</span><br><span class="line">id_of_settimeout 调用 setTimeout() 函数时所获得的返回值，使用该返回标识符作为参数，可以取消该 setTimeout() 所设定的定时执行操作。</span><br></pre></td></tr></table></figure><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><div id="close"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.close()</span><br></pre></td></tr></table></figure><h4 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a>confirm()</h4><div id="confirm"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirm(message)</span><br></pre></td></tr></table></figure><h4 id="createPopup"><a href="#createPopup" class="headerlink" title="createPopup()"></a>createPopup()</h4><div id="createPopup"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.createPopup()</span><br></pre></td></tr></table></figure><h4 id="focus"><a href="#focus" class="headerlink" title="focus()"></a>focus()</h4><div id="focus"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.focus()</span><br></pre></td></tr></table></figure><h4 id="moveBy"><a href="#moveBy" class="headerlink" title="moveBy()"></a>moveBy()</h4><div id="moveBy"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.moveBy(x,y)</span><br></pre></td></tr></table></figure><h4 id="moveTo"><a href="#moveTo" class="headerlink" title="moveTo()"></a>moveTo()</h4><div id="moveTo"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.moveTo(x,y)</span><br></pre></td></tr></table></figure><h4 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h4><div id="open"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(URL,name,specs,replace)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/open0.png?raw=true" alt=""><br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/open1.png?raw=true" alt=""></p><h4 id="print"><a href="#print" class="headerlink" title="print()"></a>print()</h4><div id="print"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.print()</span><br></pre></td></tr></table></figure><h4 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h4><div id="prompt"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prompt(msg,defaultText)</span><br></pre></td></tr></table></figure><h4 id="resizeBy"><a href="#resizeBy" class="headerlink" title="resizeBy()"></a>resizeBy()</h4><div id="resizeBy"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resizeBy(width,height)</span><br><span class="line">resizeBy() 方法用于根据指定的像素来调整窗口的大小。</span><br><span class="line">注意： 此方法定义指定窗口的右下角角落移动的像素，左上角将不会被移动(它停留在其原来的坐标).</span><br></pre></td></tr></table></figure><h4 id="resizeTo"><a href="#resizeTo" class="headerlink" title="resizeTo()"></a>resizeTo()</h4><div id="resizeTo"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.resizeTo(width,height)</span><br></pre></td></tr></table></figure><h4 id="scrollBy"><a href="#scrollBy" class="headerlink" title="scrollBy()"></a>scrollBy()</h4><div id="scrollBy"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scrollBy(xnum,ynum)</span><br><span class="line">scrollBy() 方法可把内容滚动指定的像素数。</span><br><span class="line">注意： 要使此方法工作 window 滚动条的可见属性必须设置为true！</span><br></pre></td></tr></table></figure><br><br>|参数|说明|<br>|——|——|<br>|xnum|必需。把文档向右滚动的像素数。|<br>|ynum|必需。把文档向下滚动的像素数。|<br><br>#### scrollTo()<br><br><div id="scrollTo"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scrollTo() 方法可把内容滚动到指定的坐标。</span><br><span class="line">scrollTo(xpos,ypos)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>xpos</td><td>必需。要在窗口文档显示区左上角显示的文档的 x 坐标。</td></tr><tr><td>ypos</td><td>必需。要在窗口文档显示区左上角显示的文档的 y 坐标。</td></tr></tbody></table><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h4><div id="setInterval"></div><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>code/function</td><td>必需。要调用一个代码串，也可以是一个函数</td></tr><tr><td>milliseconds</td><td>必须。周期性执行或调用 code/function 之间的时间间隔，以毫秒计。</td></tr><tr><td>param1, param2, …</td><td>可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回一个 ID（数字），可以将这个ID传递给clearInterval()，clearTimeout() 以取消执行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">setInterval(code, milliseconds);</span><br><span class="line">setInterval(function, milliseconds, param1, param2, ...)</span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h4><div id="setTimeout"></div><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>code/function</td><td>必需。要调用一个代码串，也可以是一个函数</td></tr><tr><td>milliseconds</td><td>可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。</td></tr><tr><td>param1, param2, …</td><td>可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">setTimeout(code, milliseconds, param1, param2, ...)</span><br><span class="line">setTimeout(function, milliseconds, param1, param2, ...)</span><br></pre></td></tr></table></figure><h1 id="Navigator-对象"><a href="#Navigator-对象" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h1><h2 id="Navigator-对象-1"><a href="#Navigator-对象-1" class="headerlink" title="Navigator 对象"></a>Navigator 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Navigator 对象包含有关浏览器的信息。</span><br><span class="line">注意： 没有应用于 navigator 对象的公开标准，不过所有浏览器都支持该对象。</span><br></pre></td></tr></table></figure><h2 id="Navigator-对象属性"><a href="#Navigator-对象属性" class="headerlink" title="Navigator 对象属性"></a>Navigator 对象属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>appCodeName</td><td>返回浏览器的代码名</td></tr><tr><td>appName</td><td>返回浏览器的名称</td></tr><tr><td>appVersion</td><td>返回浏览器的平台和版本信息</td></tr><tr><td>cookieEnabled</td><td>返回指明浏览器中是否启用 cookie 的布尔值</td></tr><tr><td>platform</td><td>返回运行浏览器的操作系统平台</td></tr><tr><td></td></tr><tr><td>userAgent</td><td>返回由客户机发送服务器的user-agent 头部的值</td></tr></tbody></table><h2 id="Navigator-对象方法"><a href="#Navigator-对象方法" class="headerlink" title="Navigator 对象方法"></a>Navigator 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>javaEnabled()</td><td>指定是否在浏览器中启用Java</td></tr><tr><td>taintEnabled()</td><td>规定浏览器是否启用数据污点(data tainting)（目前只有IE和Opera浏览器支持）</td></tr></tbody></table><h1 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h1><h2 id="Screen-对象-1"><a href="#Screen-对象-1" class="headerlink" title="Screen 对象"></a>Screen 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Screen 对象包含有关客户端显示屏幕的信息。</span><br><span class="line">注意： 没有应用于 screen 对象的公开标准，不过所有浏览器都支持该对象。</span><br></pre></td></tr></table></figure><h2 id="Screen-对象属性"><a href="#Screen-对象属性" class="headerlink" title="Screen 对象属性"></a>Screen 对象属性</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>availHeight</td><td>返回屏幕的高度（不包括Windows任务栏）</td></tr><tr><td>availWidth</td><td>返回屏幕的宽度（不包括Windows任务栏</td></tr><tr><td>colorDepth</td><td>返回目标设备或缓冲器上的调色板的比特深度</td></tr><tr><td>height</td><td>返回屏幕的总高度</td></tr><tr><td>pixelDepth</td><td>返回屏幕的颜色分辨率（每象素的位数</td></tr><tr><td>width</td><td>返回屏幕的总宽度</td></tr></tbody></table><h1 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h1><h2 id="History-对象-1"><a href="#History-对象-1" class="headerlink" title="History 对象"></a>History 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含用户（在浏览器窗口中）访问过的 URL。</span><br><span class="line">History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。</span><br><span class="line">注意： 没有应用于History对象的公开标准，不过所有浏览器都支持该对象。</span><br></pre></td></tr></table></figure><h2 id="History-对象属性"><a href="#History-对象属性" class="headerlink" title="History 对象属性"></a>History 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>length</td><td>返回历史列表中的网址数</td></tr></tbody></table><h2 id="History-对象方法"><a href="#History-对象方法" class="headerlink" title="History 对象方法"></a>History 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="#back">back()</a></td><td>加载 history 列表中的前一个 URL</td></tr><tr><td><a href="#forward">forward()</a></td><td>加载 history 列表中的下一个 URL</td></tr><tr><td><a href="#go">go()</a></td><td>加载 history 列表中的某个具体页面</td></tr></tbody></table><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="back"><a href="#back" class="headerlink" title="back()"></a>back()</h4><div id="back"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">back() 方法可加载历史列表中的前一个 URL（如果存在）。</span><br><span class="line">调用该方法的效果等价于点击后退按钮或调用 history.go(-1)。</span><br><span class="line">语法</span><br><span class="line">history.back()</span><br></pre></td></tr></table></figure><h4 id="forward"><a href="#forward" class="headerlink" title="forward()"></a>forward()</h4><div id="forward"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forward() 方法可加载历史列表中的下一个 URL。</span><br><span class="line">调用该方法的效果等价于点击前进按钮或调用 history.go(1)。</span><br><span class="line"></span><br><span class="line">语法</span><br><span class="line">history.forward()</span><br></pre></td></tr></table></figure><h4 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h4><div id="go"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go() 方法可加载历史列表中的某个具体的页面。</span><br><span class="line">该参数可以是数字，使用的是要访问的 URL 在 History 的 URL 列表中的相对位置。（-1上一个页面，1前进一个页面)。或一个字符串，字符串必须是局部或完整的URL，该函数会去匹配字符串的第一个URL。</span><br><span class="line">语法</span><br><span class="line">history.go(number|URL)</span><br></pre></td></tr></table></figure><h1 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h1><h2 id="Location-对象-1"><a href="#Location-对象-1" class="headerlink" title="Location 对象"></a>Location 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Location 对象包含有关当前 URL 的信息。</span><br><span class="line">Location 对象是 window 对象的一部分，可通过 window.Location 属性对其进行访问。</span><br><span class="line">注意： 没有应用于Location对象的公开标准，不过所有浏览器都支持该对象。</span><br></pre></td></tr></table></figure><h2 id="Location-对象属性"><a href="#Location-对象属性" class="headerlink" title="Location 对象属性"></a>Location 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="#hash">hash</a></td><td>返回一个URL的锚部分</td></tr><tr><td><a href="#host">host</a></td><td>返回一个URL的主机名和端口</td></tr><tr><td><a href="#hostname">hostname</a></td><td>返回URL的主机名</td></tr><tr><td><a href="#href">href</a></td><td>返回完整的URL</td></tr><tr><td><a href="#pathname">pathname</a></td><td>返回的URL路径名。</td></tr><tr><td><a href="#port">port</a></td><td>返回一个URL服务器使用的端口号</td></tr><tr><td><a href="#protocol">protocol</a></td><td>返回一个URL协议</td></tr><tr><td><a href="#search">search</a></td><td>返回一个URL的查询部分</td></tr></tbody></table><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><div id="hash"></div><p>####hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   alert(window.location.hash);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="host"></div><h4 id="host"><a href="#host" class="headerlink" title="host"></a>host</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var ss = window.location.host;</span><br><span class="line">  console.log(ss);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="hostname"></div><h4 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var hostname = window.location.hostname;</span><br><span class="line">    console.log(hostname);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="href"></div><h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&apos;search&apos;+location.href);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="pathname"></div><h4 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h4><div id="port"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&apos;search&apos;+location.pathname);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="port"><a href="#port" class="headerlink" title="port"></a>port</h4><div id="port"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&apos;search&apos;+location.port);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4><div id="search"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&apos;search&apos;+location.search);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="protocaol"><a href="#protocaol" class="headerlink" title="protocaol"></a>protocaol</h4><div id="protocol"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   console.log(&apos;search&apos;+location.search);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="Location-对象方法"><a href="#Location-对象方法" class="headerlink" title="Location 对象方法"></a>Location 对象方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><a href="#assign">assign(</a>)</td><td>载入一个新的文档</td></tr><tr><td><a href="#reload">reload()</a></td><td>重新载入当前文档</td></tr><tr><td><a href="#replace">replace()</a></td><td>用新的文档替换当前文档</td></tr></tbody></table><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><div id="asssign"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   window.location.assign(&apos;url&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h4><div id="reload"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   window.location.reload(state);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">如果把该方法的参数设置为 true，那么无论文档的最后修改日期是什么，它都会绕过缓存，从服务器上重新下载该文档。这与用户在单击浏览器的刷新按钮时按住 Shift 健的效果是完全一样。</span><br></pre></td></tr></table></figure><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><div id="replace"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   window.location.replace(&apos;url&apos;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Window-对象&quot;&gt;&lt;a href=&quot;#Window-对象&quot; class=&quot;headerlink&quot; title=&quot;Window 对象&quot;&gt;&lt;/a&gt;Window 对象&lt;/h1&gt;&lt;h2 id=&quot;Window-对象-1&quot;&gt;&lt;a href=&quot;#Window-对象-1&quot; c
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-Number</title>
    <link href="http://yoursite.com/2018/05/11/javascript-Number/"/>
    <id>http://yoursite.com/2018/05/11/javascript-Number/</id>
    <published>2018-05-11T01:52:26.000Z</published>
    <updated>2018-05-11T02:14:21.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number 对象是原始数值的包装对象。</span><br><span class="line">Number 创建方式 new Number()。</span><br></pre></td></tr></table></figure><h2 id="Number-对象属性"><a href="#Number-对象属性" class="headerlink" title="Number 对象属性"></a>Number 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>返回对创建此对象的 Number 函数的引用。</td></tr><tr><td>MAX_VALUE</td><td>可表示的最大的数。</td></tr><tr><td>MIN_VALUE</td><td>可表示的最小的数。</td></tr><tr><td>NEGATIVE_INFINITY</td><td>负无穷大，溢出时返回该值。</td></tr><tr><td>NaN</td><td>非数字值</td></tr><tr><td>POSITIVE_INFINITY</td><td>正无穷大，溢出时返回该值。</td></tr><tr><td>prototype</td><td>允许您有能力向对象添加属性和方法。</td></tr></tbody></table><h2 id="Number-对象方法"><a href="#Number-对象方法" class="headerlink" title="Number 对象方法"></a>Number 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="#toExponential">toExponential(x)</a></td><td>把对象的值转换为指数计数法。</td></tr><tr><td><a href="#toFixed">toFixed(x)</a></td><td>把数字转换为字符串，结果的小数点后有指定位数的数字。</td></tr><tr><td><a href="#toPrecision">toPrecision(x)</a></td><td>把数字格式化为指定的长度。</td></tr><tr><td><a href="#toString">toString()</a></td><td>把数字转换为字符串，使用指定的基数。</td></tr><tr><td><a href="#valueOf">valueOf()</a></td><td>返回一个 Number 对象的基本数字值。</td></tr></tbody></table><h2 id="Number的使用"><a href="#Number的使用" class="headerlink" title="Number的使用"></a>Number的使用</h2><p><div id="toFixed"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number = new Number(33);</span><br><span class="line">number.toFixed(3); //&quot;33.000&quot;</span><br></pre></td></tr></table></figure></p><p><div id="toPrecision"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number = new Number(33);</span><br><span class="line">number.toPrecision(3); //&quot;33.0&quot;</span><br></pre></td></tr></table></figure></p><p><div id="toString"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number = new Number(33);</span><br><span class="line">number.toString();</span><br></pre></td></tr></table></figure></p><p><div id="valueOf"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number = new Number(33);</span><br><span class="line">number.valueOf();</span><br></pre></td></tr></table></figure></p><p><div id="toExponential"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var number = new Number(33);</span><br><span class="line">number.toExponential(2);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Number-对象&quot;&gt;&lt;a href=&quot;#Number-对象&quot; class=&quot;headerlink&quot; title=&quot;Number 对象&quot;&gt;&lt;/a&gt;Number 对象&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-RegExp</title>
    <link href="http://yoursite.com/2018/05/10/javascript-RegExp/"/>
    <id>http://yoursite.com/2018/05/10/javascript-RegExp/</id>
    <published>2018-05-10T14:06:55.000Z</published>
    <updated>2018-05-11T08:35:48.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">正则表达式是描述字符模式的对象。</span><br><span class="line">正则表达式用于对字符串模式匹配及检索替换，是对字符串执行模式匹配的强大工具。</span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var patt=new RegExp(pattern,modifiers);</span><br><span class="line">或者更简单的方式:</span><br><span class="line">var patt=/pattern/modifiers;</span><br></pre></td></tr></table></figure><ul><li>pattern（模式） 描述了表达式的模式</li><li>modifiers(修饰符) 用于指定全局匹配、区分大小写的匹配和多行匹配</li><li>注意：当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 \）。比如，以下是等价的：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var re = new RegExp(&quot;\\w+&quot;);</span><br><span class="line">var re = /\w+/;</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小不敏感的匹配</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td></tr><tr><td>m</td><td>执行多行匹配</td></tr></tbody></table><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>查找方括号之间的任何字符</td></tr><tr><td>[\^abc]</td><td>查找任何不在方括号之间的字符</td></tr><tr><td>[0-9]</td><td>查找任何从 0 至 9 的数字</td></tr><tr><td>[a-z]</td><td>查找任何从小写 a 到小写 z 的字符</td></tr><tr><td>[A-Z]</td><td>查找任何从大写 A 到大写 Z 的字符</td></tr><tr><td>[A-z]</td><td>查找任何从大写 A 到小写 z 的字符</td></tr><tr><td>[adgk]</td><td>查找给定集合内的任何字符。</td></tr><tr><td>[\^adgk]</td><td>查找给定集合外的任何字符。</td></tr><tr><td>(red\</td><td>blue\</td><td>green)</td><td>查找任何指定的选项。</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>查找单个字符，除了换行和行结束符。</td></tr><tr><td>\w</td><td>查找单词字符。</td></tr><tr><td>\W</td><td>查找非单词字符。</td></tr><tr><td>\d</td><td>查找数字。</td></tr><tr><td>\D</td><td>查找非数字字符。</td></tr><tr><td>\s</td><td>查找空白字符。</td></tr><tr><td>\S</td><td>查找非空白字符。</td></tr><tr><td>\b</td><td>匹配单词边界。</td></tr><tr><td>\B</td><td>匹配非单词边界。</td></tr><tr><td>\0</td><td>查找 NULL 字符。</td></tr><tr><td>\n</td><td>查找换行符。</td></tr><tr><td>\f</td><td>查找换页符</td></tr><tr><td>\r</td><td>查找回车符。</td></tr><tr><td>\t</td><td>查找制表符。</td></tr><tr><td>\v</td><td>查找垂直制表符。</td></tr><tr><td>\xxx</td><td>查找以八进制数 xxx 规定的字符。</td></tr><tr><td>\xdd</td><td>查找以十六进制数 dd 规定的字符。</td></tr><tr><td>\uxxxx</td><td>查找以十六进制数 xxxx 规定的 Unicode 字符</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td></tr><tr><td>n{X}</td><td>匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td></tr><tr><td>n{X,}</td><td>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td></tr><tr><td>n{X,Y}</td><td>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 的”a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td></tr><tr><td>n$</td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td>^n</td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td>?=n</td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td>?!n</td><td>匹配任何其后没有紧接指定字符串 n 的字符串</td></tr></tbody></table><h2 id="Regex对象方法"><a href="#Regex对象方法" class="headerlink" title="Regex对象方法"></a>Regex对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>compile</td><td>在 1.5 版本中已废弃。 编译正则表达式。</td></tr><tr><td>exec</td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td>test</td><td>检索字符串中指定的值。返回 true 或 false。</td></tr><tr><td>toString</td><td>返回正则表达式的字符串。</td></tr></tbody></table><h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>search</td><td>检索与正则表达式相匹配的值。</td></tr><tr><td>match</td><td>找到一个或多个正则表达式的匹配。</td></tr><tr><td>replace</td><td>替换与正则表达式匹配的子串。</td></tr><tr><td>split</td><td>把字符串分割为字符串数组。</td></tr></tbody></table><h2 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>返回一个函数，该函数是一个创建RegExp 对象的原型。</td></tr><tr><td>global</td><td>判断是否设置了 “g” 修饰符</td></tr><tr><td>ignoreCase</td><td>判断是否设置了 “i” 修饰符</td></tr><tr><td>lastIndex</td><td>用于规定下次匹配的起始位置</td></tr><tr><td>multiline</td><td>判断是否设置了 “m” 修饰符</td></tr><tr><td>multiline</td><td>返回正则表达式的匹配模式</td></tr></tbody></table><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h1&gt;&lt;h2 id=&quot;RegExp-对象&quot;&gt;&lt;a href=&quot;#RegExp-对象&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-Math</title>
    <link href="http://yoursite.com/2018/05/10/javascript-Math/"/>
    <id>http://yoursite.com/2018/05/10/javascript-Math/</id>
    <published>2018-05-10T14:06:33.000Z</published>
    <updated>2018-05-11T01:51:59.591Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math（算数）对象的作用是：执行常见的算数任务。</span><br></pre></td></tr></table></figure><h2 id="Math-对象属性"><a href="#Math-对象属性" class="headerlink" title="Math 对象属性"></a>Math 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>E</td><td>返回算术常量 e，即自然对数的底数（约等于2.718）。</td></tr><tr><td>LN2</td><td>返回 2 的自然对数（约等于0.693）。</td></tr><tr><td>LN10</td><td>返回 10 的自然对数（约等于2.302）</td></tr><tr><td>LOG2E</td><td>返回以 2 为底的 e 的对数（约等于 1.414）</td></tr><tr><td>LOG10E</td><td>返回以 10 为底的 e 的对数（约等于0.434）</td></tr><tr><td>PI</td><td>返回圆周率（约等于3.14159）。</td></tr><tr><td>SQRT1_2</td><td>返回返回 2 的平方根的倒数（约等于 0.707）。</td></tr><tr><td>SQRT2</td><td>返回 2 的平方根（约等于 1.414）。</td></tr></tbody></table><h2 id="Math-对象方法"><a href="#Math-对象方法" class="headerlink" title="Math 对象方法"></a>Math 对象方法</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>round(x)</td><td>把数四舍五入为最接近的整数。</td></tr><tr><td>random()</td><td>返回 0 ~ 1 之间的随机数。</td></tr><tr><td>max(x,y,z,…,n)</td><td>返回 x,y,z,…,n 中的最高值</td></tr><tr><td>min(x,y,z,…,n)</td><td>返回 x,y,z,…,n中的最低值</td></tr><tr><td>abs(x)</td><td>返回 x 的绝对值。</td></tr><tr><td>acos(x)</td><td>返回 x 的反余弦值。</td></tr><tr><td>asin(x)</td><td>返回 x 的反正弦值。</td></tr><tr><td>atan(x)</td><td>以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td>atan2(y,x)</td><td>返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）</td></tr><tr><td>ceil(x)</td><td>对数进行上舍入。</td></tr><tr><td>cos(x)</td><td>返回数的余弦。</td></tr><tr><td>exp(x)</td><td>返回 E^x 的指数。</td></tr><tr><td>floor(x)</td><td>对 x 进行下舍入。</td></tr><tr><td>log(x)</td><td>返回数的自然对数（底为e）</td></tr><tr><td>pow(x,y)</td><td>返回 x 的 y 次幂。</td></tr><tr><td>sin(x)</td><td>返回数的正弦。</td></tr><tr><td>sqrt(x)</td><td>返回数的平方根。</td></tr><tr><td>tan(x)</td><td>返回角的正切。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-String</title>
    <link href="http://yoursite.com/2018/05/10/javascript-String/"/>
    <id>http://yoursite.com/2018/05/10/javascript-String/</id>
    <published>2018-05-10T14:06:23.000Z</published>
    <updated>2018-05-11T06:33:11.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String 对象用于处理文本（字符串）。</span><br><span class="line">String 对象创建方法： new String().</span><br></pre></td></tr></table></figure><h2 id="String-对象属性"><a href="#String-对象属性" class="headerlink" title="String 对象属性"></a>String 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>对创建该对象的函数的引用</td></tr><tr><td>length</td><td>字符串的长度</td></tr><tr><td>prototype</td><td>允许您向对象添加属性和方法</td></tr></tbody></table><h2 id="String-对象方法"><a href="#String-对象方法" class="headerlink" title="String 对象方法"></a>String 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="#charAt">charAt()</a></td><td>返回在指定位置的字符。</td></tr><tr><td><a href="#charCodeAt">charCodeAt()</a></td><td>返回在指定的位置的字符的 Unicode 编码。</td></tr><tr><td><a href="#concat">concat()</a></td><td>连接两个或更多字符串，并返回新的字符串。</td></tr><tr><td><a href="#fromCharCode">fromCharCode()</a></td><td>将 Unicode 编码转为字符。</td></tr><tr><td><a href="#indexOf">indexOf()</a></td><td>返回某个指定的字符串值在字符串中首次出现的位置</td></tr><tr><td><a href="#lastIndexOf">lastIndexOf()</a></td><td>从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置</td></tr><tr><td><a href="#match">match()</a></td><td>查找找到一个或多个正则表达式的匹配。</td></tr><tr><td><a href="#replace">replace()</a></td><td>在字符串中查找匹配的子串， 并替换与正则表达式匹配的子串。</td></tr><tr><td><a href="#search">search()</a></td><td>查找与正则表达式相匹配的值。</td></tr><tr><td><a href="#slice">slice()</a></td><td>提取字符串的片断，并在新的字符串中返回被提取的部分。</td></tr><tr><td></td></tr><tr><td><a href="#split">split()</a></td><td>把字符串分割为字符串数组。</td></tr><tr><td><a href="#substr">substr()</a></td><td>从起始索引号提取字符串中指定数目的字符。</td></tr><tr><td><a href="#substring">substring()</a></td><td>提取字符串中两个指定的索引号之间的字符。</td></tr><tr><td><a href="#toLowerCase">toLowerCase()</a></td><td>把字符串转换为小写。</td></tr><tr><td></td></tr><tr><td><a href="#toUpperCase">toUpperCase()</a></td><td>把字符串转换为大写。</td></tr><tr><td><a href="#trim">trim()</a></td><td>去除字符串两边的空白</td></tr><tr><td><a href="#valueOf">valueOf()</a></td><td>返回某个字符串对象的原始值。</td></tr></tbody></table><h2 id="String-HTML-包装方法"><a href="#String-HTML-包装方法" class="headerlink" title="String HTML 包装方法"></a>String HTML 包装方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="#anchor">anchor()</a></td><td>创建 HTML 锚。</td></tr><tr><td><a href="#big">big()</a></td><td>用大号字体显示字符串。</td></tr><tr><td><a href="#blink">blink()</a></td><td>显示闪动字符串。</td></tr><tr><td><a href="#bold">bold()</a></td><td>使用粗体显示字符串。</td></tr><tr><td><a href="#fixed">fixed()</a></td><td>以打字机文本显示字符串</td></tr><tr><td><a href="#fontcolor">fontcolor()</a></td><td>使用指定的颜色来显示字符串。</td></tr><tr><td><a href="#fontsize">fontsize()</a></td><td>使用指定的尺寸来显示字符串。</td></tr><tr><td><a href="#italics">italics()</a></td><td>使用斜体显示字符串。</td></tr><tr><td><a href="#link">link()</a></td><td>将字符串显示为链接。</td></tr><tr><td><a href="#small">small()</a></td><td>使用小字号来显示字符串。</td></tr><tr><td><a href="#strike">strike()</a></td><td>用于显示加删除线的字符串</td></tr><tr><td><a href="#sub">sub()</a></td><td>把字符串显示为下标。</td></tr><tr><td><a href="#sup">sup()</a></td><td>把字符串显示为上标。</td></tr></tbody></table><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h3><div id="charAt"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">console.log(str.charAt(0));</span><br><span class="line">注意点 ：位置必须介于[0,str.length) 之间。</span><br></pre></td></tr></table></figure><h3 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt"></a>charCodeAt</h3><div id="charCodeAt"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;abc&apos;;</span><br><span class="line">console.log(str.charCodeAt(0));</span><br><span class="line">注意点 ：位置必须介于[0,str.length) 之间。超过结果：NAN</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><div id="concat"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">函数原型 contact(string1,string2,......);</span><br><span class="line">var string1 = &apos;you are&apos;;</span><br><span class="line">var string2 = &apos;good&apos;;</span><br><span class="line">var string3 = &apos;student&apos;;</span><br><span class="line">var ss = string1.concat(string2,string3);</span><br><span class="line">console.log(ss);</span><br><span class="line">输出结果： you aregoodstudent</span><br><span class="line">注意：产生新数组，不会改变原有的字符串。</span><br></pre></td></tr></table></figure><h3 id="fromCharCode"><a href="#fromCharCode" class="headerlink" title="fromCharCode"></a>fromCharCode</h3><div id="fromCharCode"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.fromCharCode(97)</span><br><span class="line">//输出结果 “a”；</span><br></pre></td></tr></table></figure><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h3><div id="indexOf"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;youuuu&apos;;</span><br><span class="line">var index = string.indexOf(&apos;u&apos;);</span><br><span class="line">index 代表第一次出现&apos;u&apos;的索引值。</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h3><div id="lastIndexOf"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;youuuu&apos;;</span><br><span class="line">var index = string.lastIndexOf(&apos;u&apos;);</span><br><span class="line">index 代表最后出现&apos;u&apos;的索引值。</span><br></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><div id="match"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var string = &apos;The rain in SPAIN stays mainly in the plain&apos;;</span><br><span class="line">string.match(\you\g);</span><br><span class="line">输出  [&quot;ain&quot;, &quot;ain&quot;, &quot;ain&quot;]</span><br><span class="line">返回结果 数组</span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><div id="replace"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法 string.replace(searchvalue,newvalue);</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchvalue</td><td>必须。规定子字符串或要替换的模式的 RegExp 对象。请注意，如果该值是一个字符串，则将它作为要检索的直接量文本模式，而不是首先被转换为 RegExp 对象。</td></tr><tr><td>newvalue</td><td>必需。一个字符串值。规定了替换文本或生成替换文本的函数。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;Mr Blue has a blue house and a blue car&quot;;</span><br><span class="line">var n=str.replace(/blue/g,&quot;red&quot;);</span><br><span class="line">结果：Mr Blue has a red house and a red car</span><br><span class="line">注意点：产生一个新的数组</span><br></pre></td></tr></table></figure><div id="search"></div><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.search(searchvalue)</span><br></pre></td></tr></table></figure><p>参数值</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchvalue</td><td>必须。查找的字符串或者正则表达式。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Number</td><td>与指定查找的字符串或者正则表达式相匹配的 String 对象起始位置。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;Mr. Blue has a blue house&quot;;</span><br><span class="line">var n = str.search(&apos;blue&apos;);</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><div id="slice"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.slice(start,end)</span><br></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>必须. 要抽取的片断的起始下标。第一个字符位置为 0</td></tr><tr><td>end</td><td>可选。 紧接着要抽取的片段的结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>提取的字符串</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;Hello world!&quot;;</span><br><span class="line">var n=str.slice(0);</span><br><span class="line">结果：Hello world!</span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><div id="split"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.split(separator,limit)</span><br></pre></td></tr></table></figure><p>参数</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>separator</td><td>可选。字符串或正则表达式，从该参数指定的地方分割 string Object。</td></tr><tr><td>limit</td><td>可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Array</td><td>一个字符串数组。该数组是通过在separator指定的边界处将字符串 string Object 分割成子串创建的。返回的数组中的字串不包括 separator 自身。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;How are you doing today?&quot;;</span><br><span class="line">var n=str.split();</span><br><span class="line">[How are you doing today?&quot;]</span><br></pre></td></tr></table></figure><h3 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h3><div id="substr"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.substr(start,length)</span><br></pre></td></tr></table></figure><p>参数值</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</td></tr><tr><td>length</td><td>可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>A new string containing the extracted part of the text</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;Hello world!&quot;;</span><br><span class="line">var n=str.substr(2)</span><br><span class="line">结果：llo world!</span><br></pre></td></tr></table></figure><h3 id="substring-方法返回的子串包括-开始-处的字符，但不包括-结束-处的字符。"><a href="#substring-方法返回的子串包括-开始-处的字符，但不包括-结束-处的字符。" class="headerlink" title="substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。"></a>substring() 方法返回的子串包括 开始 处的字符，但不包括 结束 处的字符。</h3><div id="substring"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string.substring(from, to)</span><br></pre></td></tr></table></figure><p>参数值</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>from</td><td>必需。一个非负的整数，规定要提取的子串的第一个字符在 string Object 中的位置。</td></tr><tr><td>to</td><td>可选。一个非负的整数，比要提取的子串的最后一个字符在 string Object 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>子串</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var str=&quot;Hello world!&quot;</span><br><span class="line">str.substring(0);</span><br><span class="line">Hello world!</span><br></pre></td></tr></table></figure><div id="anchor"></div><h3 id="创建锚点-anchor"><a href="#创建锚点-anchor" class="headerlink" title="创建锚点 anchor"></a>创建锚点 anchor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var txt = &quot;Chapter 10&quot;;</span><br><span class="line">   txt.anchor(&quot;chap10&quot;);</span><br><span class="line">   alert(txt.anchor(&quot;chap10&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="big"></div><h3 id="big"><a href="#big" class="headerlink" title="big()"></a>big()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.big());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="blink"></div><h3 id="blink-目前只有Firefox-和-Opera-浏览器支持"><a href="#blink-目前只有Firefox-和-Opera-浏览器支持" class="headerlink" title="blink() 目前只有Firefox 和 Opera 浏览器支持"></a>blink() 目前只有Firefox 和 Opera 浏览器支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.blink());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><div id="bold"></div><h3 id="bold-显示粗体"><a href="#bold-显示粗体" class="headerlink" title="bold 显示粗体"></a>bold 显示粗体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.bold());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="fixed"></div></p><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed()"></a>fixed()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.fixed());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="fontcolor"></div></p><h3 id="fontcolor"><a href="#fontcolor" class="headerlink" title="fontcolor()"></a>fontcolor()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">  document.write(str.fontcolor(&quot;green&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="fontsize"></div></p><h3 id="fontsize"><a href="#fontsize" class="headerlink" title="fontsize()"></a>fontsize()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.fontsize(7));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="italics"></div></p><h3 id="italics"><a href="#italics" class="headerlink" title="italics"></a>italics</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.italics());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="link"></div></p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Free Web Building Tutorials!&quot;;</span><br><span class="line">   document.write(str.link(&quot;http://www.w3cschool.cc&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="small"></div></p><h3 id="samll"><a href="#samll" class="headerlink" title="samll"></a>samll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.small());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="strike"></div></p><h3 id="strike"><a href="#strike" class="headerlink" title="strike()"></a>strike()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.strike());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="sub"></div></p><h3 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.sub());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><div id="sup"></div></p><h3 id="sup"><a href="#sup" class="headerlink" title="sup()"></a>sup()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var str = &quot;Hello world!&quot;;</span><br><span class="line">   document.write(str.sup());</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;String-对象&quot;&gt;&lt;a href=&quot;#String-对象&quot; class=&quot;headerlink&quot; title=&quot;String 对象&quot;&gt;&lt;/a&gt;String 对象&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-Date</title>
    <link href="http://yoursite.com/2018/05/10/javascript-Date/"/>
    <id>http://yoursite.com/2018/05/10/javascript-Date/</id>
    <published>2018-05-10T13:30:18.000Z</published>
    <updated>2018-05-10T13:55:48.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JavaScript-Date-对象"><a href="#JavaScript-Date-对象" class="headerlink" title="JavaScript Date 对象"></a>JavaScript Date 对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Date 对象</span><br><span class="line">Date 对象用于处理日期与时间。</span><br><span class="line">创建 Date 对象： new Date()</span><br><span class="line">以下四种方法同样可以创建 Date 对象：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">var d = new Date(milliseconds);</span><br><span class="line">var d = new Date(dateString);</span><br><span class="line">var d = new Date(year, month, day, hours, minutes, seconds, milliseconds);</span><br></pre></td></tr></table></figure><h4 id="Date-对象属性"><a href="#Date-对象属性" class="headerlink" title="Date 对象属性"></a>Date 对象属性</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>返回对创建此对象的 Date 函数的引用。</td></tr><tr><td>prototype</td><td>使您有能力向对象添加属性和方法。</td></tr></tbody></table><h4 id="Date-对象方法"><a href="#Date-对象方法" class="headerlink" title="Date 对象方法"></a>Date 对象方法</h4><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>getDate()</td><td>从 Date 对象返回一个月中的某一天(1 ~ 31)。</td></tr><tr><td>getDay()</td><td>从 Date 对象返回一周中的某一天 (0 ~ 6)。</td></tr><tr><td>getFullYear()</td><td>从 Date 对象以四位数字返回年份。</td></tr><tr><td>getHours()</td><td>返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getMilliseconds()</td><td>返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>getMinutes()</td><td>返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getMonth()</td><td>从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getSeconds()</td><td>返回 Date 对象的秒数 (0 ~ 59)。</td></tr><tr><td>getTime()</td><td>返回 1970 年 1 月 1 日至今的毫秒数。</td></tr><tr><td>getTimezoneOffset()</td><td>返回本地时间与格林威治标准时间 (GMT) 的分钟差。</td></tr><tr><td>getUTCDate()</td><td>根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。</td></tr><tr><td>getUTCDay()</td><td>根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。</td></tr><tr><td>getUTCFullYear()</td><td>根据世界时从 Date 对象返回四位数的年份。</td></tr><tr><td>getUTCHours()</td><td>根据世界时返回 Date 对象的小时 (0 ~ 23)。</td></tr><tr><td>getUTCMilliseconds()</td><td>根据世界时返回 Date 对象的毫秒(0 ~ 999)。</td></tr><tr><td>getUTCMinutes()</td><td>根据世界时返回 Date 对象的分钟 (0 ~ 59)。</td></tr><tr><td>getUTCMonth()</td><td>根据世界时从 Date 对象返回月份 (0 ~ 11)。</td></tr><tr><td>getUTCSeconds()</td><td>根据世界时返回 Date 对象的秒钟 (0 ~ 59)。</td></tr><tr><td>getYear()</td><td>已废弃。 请使用 getFullYear() 方法代替。</td></tr><tr><td>parse()</td><td>返回1970年1月1日午夜到指定日期（字符串）的毫秒数。</td></tr><tr><td>setDate()</td><td>设置 Date 对象中月的某一天 (1 ~ 31)。</td></tr><tr><td>setFullYear()</td><td>设置 Date 对象中的年份（四位数字）。</td></tr><tr><td>setHours()</td><td>设置 Date 对象中的小时 (0 ~ 23)。</td></tr><tr><td>setMilliseconds()</td><td>设置 Date 对象中的毫秒 (0 ~ 999)</td></tr><tr><td>setMinutes()</td><td>设置 Date 对象中的分钟 (0 ~ 59)。</td></tr><tr><td>setMonth()</td><td>设置 Date 对象中月份 (0 ~ 11)。</td></tr><tr><td>setSeconds()</td><td>设置 Date 对象中的秒钟 (0 ~ 59)。</td></tr><tr><td>setTime()</td><td>setTime() 方法以毫秒设置 Date 对象</td></tr><tr><td>setUTCDate()</td><td>根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。</td></tr><tr><td>setUTCFullYear()</td><td>setUTCFullYear()</td></tr></tbody></table><p>根据世界时设置 Date 对象中的年份（四位数字）。|<br>|setUTCHours()|根据世界时设置 Date 对象中的小时 (0 ~ 23)。|<br>|setUTCMilliseconds()|根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。|<br>|setUTCMinutes()|根据世界时设置 Date 对象中的分钟 (0 ~ 59)。|<br>|setUTCMonth()|根据世界时设置 Date 对象中的月份 (0 ~ 11)。|<br>|setUTCSeconds()|setUTCSeconds() 方法用于根据世界时 (UTC) 设置指定时间的秒字段。|<br>|setYear()|已废弃。请使用 setFullYear() 方法代替。|<br>|toDateString()|把 Date 对象的日期部分转换为字符串。|<br>|toGMTString()|已废弃。请使用 toUTCString() 方法代替。|<br>|toISOString()|使用 ISO 标准返回字符串的日期格式。|<br>|toJSON()|以 JSON 数据格式返回日期字符串。|<br>|toLocaleDateString()|根据本地时间格式，把 Date 对象的日期部分转换为字符串。|<br>|toLocaleTimeString()|根据本地时间格式，把 Date 对象的时间部分转换为字符串。|<br>|toLocaleString()|据本地时间格式，把 Date 对象转换为字符串。|<br>|toString()|把 Date 对象转换为字符串。|<br>|toTimeString()|把 Date 对象的时间部分转换为字符串。|<br>|toUTCString()|根据世界时，把 Date 对象转换为字符串。|<br>|UTC()|根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。|<br>|valueOf()|返回 Date 对象的原始值。|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JavaScript-Date-对象&quot;&gt;&lt;a href=&quot;#JavaScript-Date-对象&quot; class=&quot;headerlink&quot; title=&quot;JavaScript Date 对象&quot;&gt;&lt;/a&gt;JavaScript Date 对象&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>javascript-1</title>
    <link href="http://yoursite.com/2018/05/10/javascript-1/"/>
    <id>http://yoursite.com/2018/05/10/javascript-1/</id>
    <published>2018-05-10T05:49:24.000Z</published>
    <updated>2018-05-10T13:26:23.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = new Array();</span><br><span class="line">array.push(1);</span><br><span class="line">array.push(&apos;c&apos;);</span><br><span class="line"></span><br><span class="line">var array = new Array(size);</span><br><span class="line"></span><br><span class="line">var array = new Array(1,2);</span><br></pre></td></tr></table></figure><h3 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = new Array();</span><br><span class="line">array.push(1);</span><br><span class="line">array.push(&apos;c&apos;);</span><br><span class="line">array[0] = &apos;ffd&apos;;</span><br></pre></td></tr></table></figure><h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var length = array.length;</span><br></pre></td></tr></table></figure><h3 id="数组查值"><a href="#数组查值" class="headerlink" title="数组查值"></a>数组查值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var index = array.indexOf(&apos;Volvo&apos;);</span><br><span class="line">index 表示 ‘Volvo’ 在数组中的索引值，-1 表示不存在</span><br></pre></td></tr></table></figure><h3 id="contact"><a href="#contact" class="headerlink" title="contact"></a>contact</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">连接两个或者多个数组</span><br><span class="line">var arr = [2,3]</span><br><span class="line">var arr1 = [3];</span><br><span class="line">arr.contact(arr1) 产生新数组</span><br><span class="line">[2,3,3]</span><br></pre></td></tr></table></figure><h3 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyWithin() 方法用于从数组的指定位置拷贝元素到数组的另一个指定位置中修改数组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.copyWithin(target, start, end)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td></td><td>target</td><td>必需。复制到指定目标索引位置。</td><td></td></tr><tr><td></td><td>start</td><td>可选。元素复制的起始位置。</td><td></td></tr><tr><td></td><td>end</td><td>可选。停止复制的索引位置 (默认为 array.length)</td><td></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">array.copyWithin(3,0,2);</span><br><span class="line">[1, 2, 3, 1, 2, 6, 7, 8, 9, 10]</span><br><span class="line">array.copyWithin(3,2,2);</span><br><span class="line">[1, 2, 3, 1, 2, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><p>返回值<br>|Type|描述|<br>|——|——-|<br>|Array|数组|</p><h3 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</span><br><span class="line">注意: forEach() 对于空数组是不会执行回调函数的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.forEach(function(currentValue, index, arr), thisValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png?raw=true" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = new Array(11, 22, 33, 44, 55, 66);</span><br><span class="line">  array.forEach(function(value, index, array) &#123;</span><br><span class="line">      console.log(value);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="isArray-判断是否是数组"><a href="#isArray-判断是否是数组" class="headerlink" title="isArray 判断是否是数组"></a>isArray 判断是否是数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray(&apos;ss&apos;); 返回 false</span><br><span class="line">Array.isArray([]); 返回 true</span><br></pre></td></tr></table></figure><h3 id="join-把数组所有的元素放到一个字符串中"><a href="#join-把数组所有的元素放到一个字符串中" class="headerlink" title="join 把数组所有的元素放到一个字符串中"></a>join 把数组所有的元素放到一个字符串中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2].join() 结果 &quot;1,2&quot;</span><br></pre></td></tr></table></figure><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys() 方法用于从数组创建一个包含数组键的可迭代对象。</span><br><span class="line">如果对象是数组返回 true，否则返回 false。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.keys()</span><br></pre></td></tr></table></figure><p>返回值</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>ArrayItreator</td><td>数组迭代对象</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [3,4,5,6];</span><br><span class="line">array.keys();</span><br></pre></td></tr></table></figure><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse() 方法用于颠倒数组中元素的顺序。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数声明 array.reverse()</span><br></pre></td></tr></table></figure><p>返回值<br>|类型|描述|<br>|——|———-|<br>|Array|颠倒顺序后的数组|</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = new Array(1,2);</span><br><span class="line">array.revese();</span><br></pre></td></tr></table></figure><h3 id="includes-includes-方法用来判断一个数组是否包含一个指定的值，如果是返回-true，否则false。"><a href="#includes-includes-方法用来判断一个数组是否包含一个指定的值，如果是返回-true，否则false。" class="headerlink" title="includes includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。"></a>includes includes() 方法用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 arr.includes(searchElement, fromIndex)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>searchElement</td><td>必须。需要查找的元素值。</td></tr><tr><td>fromIndex</td><td>可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</td></tr><tr><td>返回值</td><td>true或者false</td></tr></tbody></table><h3 id="find-查找"><a href="#find-查找" class="headerlink" title="find 查找"></a>find 查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.find(function(currentValue, index, arr),thisValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png&amp;raw=true" alt=""></p><table><thead><tr><th></th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>数组</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [3,3,4,5,6]</span><br><span class="line">function check(age)&#123;</span><br><span class="line">    age&gt;4;</span><br><span class="line">&#125;</span><br><span class="line">array.find(check);</span><br></pre></td></tr></table></figure><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</span><br><span class="line">findIndex() 方法为数组中的每个元素都调用一次函数执行：</span><br><span class="line">当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</span><br><span class="line">如果没有符合条件的元素返回 -1</span><br><span class="line">注意: findIndex() 对于空数组，函数是不会执行的。</span><br><span class="line">注意: findIndex() 并没有改变数组的原始值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png&amp;raw=true" alt="">;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var ages = [3, 10, 18, 20];</span><br><span class="line"> </span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &gt;= 18;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML = ages.findIndex(checkAdult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>新数组</td></tr></tbody></table><h3 id="slice-数组截取"><a href="#slice-数组截取" class="headerlink" title="slice 数组截取"></a>slice 数组截取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice() 方法可从已有的数组中返回选定的元素。</span><br><span class="line">slice()方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.slice(start, end)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>start</td><td>可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td></tr><tr><td>end</td><td>可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>Type</th><th>描述</th></tr></thead><tbody><tr><td>Array</td><td>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">var myBest = fruits.slice(-3,-1);</span><br><span class="line">Lemon,Apple</span><br></pre></td></tr></table></figure><h3 id="some-检测数组元素中是否有元素符合指定条件。"><a href="#some-检测数组元素中是否有元素符合指定条件。" class="headerlink" title="some() 检测数组元素中是否有元素符合指定条件。"></a>some() 检测数组元素中是否有元素符合指定条件。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</span><br><span class="line">some() 方法会依次执行数组的每个元素：</span><br><span class="line">如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</span><br><span class="line">如果没有满足条件的元素，则返回false。</span><br><span class="line">注意： some() 不会对空数组进行检测。</span><br><span class="line">注意： some() 不会改变原始数组。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">array.some(function(currentValue,index,arr),thisValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png?raw=true" alt=""></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>bool类型</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ages = [4, 12, 16, 20];</span><br><span class="line"></span><br><span class="line">function checkAdult(age) &#123;</span><br><span class="line">    return age &gt;=0;</span><br><span class="line">&#125;</span><br><span class="line">ages.som(checkAdult)</span><br></pre></td></tr></table></figure><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort 排序"></a>sort 排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数原型: array.sort(sortfunction)</span><br><span class="line">1.原数组上进行排序 不产生副本</span><br><span class="line">2.默认排序顺序为按字母升序。</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td></td><td>sortfunction</td><td>可选。规定排序顺序。必须是函数。</td></tr><tr><td></td><td>返回值</td><td>对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,-1,3,4];</span><br><span class="line">array.sort();</span><br><span class="line">[-1, 1, 2, 3, 3, 4, 4]</span><br><span class="line"></span><br><span class="line">function check(value1,value2)&#123;</span><br><span class="line">    return value1&lt;value2;</span><br><span class="line">&#125;</span><br><span class="line">array.sort(check); //降序排列</span><br></pre></td></tr></table></figure><h3 id="从数组中添加或删除元素。"><a href="#从数组中添加或删除元素。" class="headerlink" title="从数组中添加或删除元素。"></a>从数组中添加或删除元素。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">splice() 方法用于插入、删除或替换数组的元素。</span><br><span class="line">注意：这种方法会改变原始数组！。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数声明 array.splice(index,howmany,item1,.....,itemX)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>必需。规定从何处添加/删除元素。该参数是开始插入和（或）删除的数组元素的下标，必须是数字</td></tr><tr><td>howmany</td><td>必需。规定应该删除多少元素。必须是数字，但可以是 “0”。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</td></tr><tr><td>item1, …, itemX</td><td>可选。要添加到数组的新元素</td></tr></tbody></table><p>返回值</p><table><thead><tr><th>Type</th><th>描述</th></tr></thead><tbody><tr><td>Array</td><td>如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</td></tr></tbody></table><h3 id="toString-把数组转换为字符串，并返回结果。"><a href="#toString-把数组转换为字符串，并返回结果。" class="headerlink" title="toString() 把数组转换为字符串，并返回结果。"></a>toString() 把数组转换为字符串，并返回结果。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toString() 方法可把数组转换为字符串，并返回结果。</span><br><span class="line">注意： 数组中的元素之间用逗号分隔。</span><br></pre></td></tr></table></figure><h3 id="unshift-向数组的开头添加一个或更多元素，并返回新的长度。"><a href="#unshift-向数组的开头添加一个或更多元素，并返回新的长度。" class="headerlink" title="unshift() 向数组的开头添加一个或更多元素，并返回新的长度。"></a>unshift() 向数组的开头添加一个或更多元素，并返回新的长度。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。</span><br><span class="line">注意： 该方法将改变数组的数目。</span><br><span class="line">提示: 将新项添加到数组末尾，请使用 push() 方法。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.unshift(item1,item2, ..., itemX)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>item1,item2, …, itemX</td><td>可选。向数组起始位置添加一个或者多个元素</td></tr></tbody></table><h3 id="valueOf-返回数组对象的原始值。"><a href="#valueOf-返回数组对象的原始值。" class="headerlink" title="valueOf() 返回数组对象的原始值。"></a>valueOf() 返回数组对象的原始值。</h3><h3 id="pop-删除最后的一个元素并返回删除的元素"><a href="#pop-删除最后的一个元素并返回删除的元素" class="headerlink" title="pop() 删除最后的一个元素并返回删除的元素"></a>pop() 删除最后的一个元素并返回删除的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop() 方法用于删除数组的最后一个元素并返回删除的元素。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型  array.pop()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [2,3,4,5,6];</span><br><span class="line">array.pop();</span><br></pre></td></tr></table></figure><h3 id="lastIndexOf-返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。"><a href="#lastIndexOf-返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。" class="headerlink" title="lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。"></a>lastIndexOf() 返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</span><br><span class="line">如果要检索的字符串值没有出现，则该方法返回 -1。</span><br><span class="line">该方法将从尾到头地检索字符串 stringObject，看它是否含有子串 searchvalue。开始检索的位置在字符串的 fromindex 处或字符串的结尾（没有指定 fromindex 时）。如果找到一个 searchvalue，则返回 searchvalue 的第一个字符在 stringObject 中的位置。stringObject 中的字符位置是从 0 开始的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数声明 array.lastIndexOf(item,start)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>item</td><td>必需。规定需检索的字符串值。</td></tr><tr><td>start</td><td>可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。</td></tr><tr><td>返回值</td><td>Number 如果在 stringObject 中的 fromindex 位置之前存在 searchvalue，则返回的是出现的最后一个 searchvalue 的位置。</td></tr></tbody></table><h3 id="map-通过指定函数处理数组的每个元素，并返回处理后的数组。"><a href="#map-通过指定函数处理数组的每个元素，并返回处理后的数组。" class="headerlink" title="map  通过指定函数处理数组的每个元素，并返回处理后的数组。"></a>map  通过指定函数处理数组的每个元素，并返回处理后的数组。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</span><br><span class="line">map() 方法按照原始数组元素顺序依次处理元素。</span><br><span class="line">注意： map() 不会对空数组进行检测。</span><br><span class="line">注意： map() 不会改变原始数组。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型：array.map(function(currentValue,index,arr), thisValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png?raw=true" alt=""></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [4, 9, 16, 25];</span><br><span class="line">var x = [4, 9, 16, 25];</span><br></pre></td></tr></table></figure><h3 id="reduce-将数组元素计算为一个值（从左到右）"><a href="#reduce-将数组元素计算为一个值（从左到右）" class="headerlink" title="reduce() 将数组元素计算为一个值（从左到右）"></a>reduce() 将数组元素计算为一个值（从左到右）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">reduce() 可以作为一个高阶函数，用于函数的 compose。</span><br><span class="line">注意: reduce() 对于空数组是不会执行回调函数的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法 array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_reduce.png?raw=true" alt=""></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>返回计算结果</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [15.5, 2.3, 1.1, 4.7];</span><br><span class="line"> function getSum(total, num) &#123;</span><br><span class="line">    return total + Math.round(num);</span><br><span class="line">&#125;</span><br><span class="line">numbers.reduce(getSum, 0);</span><br></pre></td></tr></table></figure><h3 id="reduceRight-将数组元素计算为一个值（从右到左）。"><a href="#reduceRight-将数组元素计算为一个值（从右到左）。" class="headerlink" title="reduceRight() 将数组元素计算为一个值（从右到左）。"></a>reduceRight() 将数组元素计算为一个值（从右到左）。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure><h3 id="shift-删除并返回数组的第一个元素。"><a href="#shift-删除并返回数组的第一个元素。" class="headerlink" title="shift() 删除并返回数组的第一个元素。"></a>shift() 删除并返回数组的第一个元素。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法:array.shift()</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>数组原来的第一个元素的值（移除的元素）。</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];</span><br><span class="line">fruits.shift();</span><br></pre></td></tr></table></figure><h3 id="fill-填充数组"><a href="#fill-填充数组" class="headerlink" title="fill 填充数组"></a>fill 填充数组</h3><p>函数原型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.fill(value, start, end)</span><br></pre></td></tr></table></figure></p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>必需。填充的值。</td></tr><tr><td>start</td><td>可选。开始填充位置</td></tr><tr><td>end</td><td>可选。停止填充位置 (默认为 array.length)</td></tr><tr><td>返回值</td><td>数组</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5,6]</span><br><span class="line">array.fill(99);</span><br></pre></td></tr></table></figure><h3 id="every-检测数值元素的每个元素是否都符合条件。"><a href="#every-检测数值元素的每个元素是否都符合条件。" class="headerlink" title="every() 检测数值元素的每个元素是否都符合条件。"></a>every() 检测数值元素的每个元素是否都符合条件。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</span><br><span class="line">every() 方法使用指定函数检测数组中的所有元素：如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</span><br><span class="line">如果所有元素都满足条件，则返回 true。</span><br></pre></td></tr></table></figure><blockquote><pre><code>函数原型 array.every(function(currentValue,index,arr), thisValue)</code></pre></blockquote><blockquote></blockquote><p><span>参数说明</span></p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png?raw=true" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function checkAge(age)&#123;</span><br><span class="line">return age&gt;8;</span><br><span class="line">&#125;</span><br><span class="line">var array = new Array(2,3,4,5,18);</span><br><span class="line">array.every(checkAge); // false</span><br><span class="line">var array = new Array(18,8);</span><br><span class="line">array.every(checkAge);// true</span><br></pre></td></tr></table></figure><h3 id="fillter-过滤"><a href="#fillter-过滤" class="headerlink" title="fillter 过滤"></a>fillter 过滤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</span><br><span class="line">filter() 不会对空数组进行检测。</span><br><span class="line">filter() 不会改变原始数组。</span><br></pre></td></tr></table></figure><p><span>参数说明</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">函数原型 </span><br><span class="line">   array.filter(function(currentValue,index,arr), thisValue)</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/array_every.png?raw=true" alt=""></p><table><thead><tr><th></th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>返回值</td><td>数组</td></tr></tbody></table><h3 id="entries-数组迭代对象"><a href="#entries-数组迭代对象" class="headerlink" title="entries 数组迭代对象"></a>entries 数组迭代对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。</span><br><span class="line">迭代对象中数组的索引值作为 key， 数组元素作为 value。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 array.entries()</span><br></pre></td></tr></table></figure><h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from() 方法用于通过拥有 length 属性的对象或可迭代的对象来返回一个数组。</span><br><span class="line">如果对象是数组返回 true，否则返回 false。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数原型 Array.from(object, mapFunction, thisValue)</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>object</td><td>必需，要转换为数组的对象。</td></tr><tr><td>mapFunction</td><td>可选，数组中每个元素要调用的函数。</td></tr><tr><td>thisValue</td><td>可选，映射函数(mapFunction)中的 this 对象。</td></tr><tr><td>返回值</td><td>新数组</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr = Array.from([1, 2, 3], x =&gt; x * 10);</span><br><span class="line">// arr[0] == 10;</span><br><span class="line">// arr[1] == 20;</span><br><span class="line">// arr[2] == 30;</span><br><span class="line"></span><br><span class="line">var myArr = Array.from(&quot;RUNOOB&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;&lt;/a&gt;方法&lt;/h2&gt;&lt;h3 id
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>对角线表头的表格</title>
    <link href="http://yoursite.com/2018/05/09/%E5%AF%B9%E8%A7%92%E7%BA%BF%E8%A1%A8%E5%A4%B4%E7%9A%84%E8%A1%A8%E6%A0%BC/"/>
    <id>http://yoursite.com/2018/05/09/对角线表头的表格/</id>
    <published>2018-05-09T08:58:26.000Z</published>
    <updated>2018-05-11T08:36:28.605Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近项目要通过html实现部分页面</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/table.png?raw=true" alt=""></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><pre><code>一开始打算使用画布去实现，在实现的过程中遇到了，一个很严重的问题，线存在着失真的现象，最后是通过transform去进行旋转。</code></pre></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><div style="background-color:red;width:100px;height:200px"><br>    <div style="width:150px;height:1px;background-color:yellow"></div><br>    <!--<div style="position:relative;left:50px">left</div>    <div>right</div>--><br></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="html" scheme="http://yoursite.com/categories/html/"/>
    
    
  </entry>
  
  <entry>
    <title>ul-li结构浮动</title>
    <link href="http://yoursite.com/2018/05/08/ul-li%E7%BB%93%E6%9E%84%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2018/05/08/ul-li结构浮动/</id>
    <published>2018-05-08T07:35:56.000Z</published>
    <updated>2018-05-11T08:36:38.926Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>AudioUnit</title>
    <link href="http://yoursite.com/2018/05/08/AudioUnit/"/>
    <id>http://yoursite.com/2018/05/08/AudioUnit/</id>
    <published>2018-05-08T01:01:43.000Z</published>
    <updated>2018-05-08T01:01:43.958Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MAC配置</title>
    <link href="http://yoursite.com/2018/05/08/Mac%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/05/08/Mac配置文件/</id>
    <published>2018-05-08T00:58:58.000Z</published>
    <updated>2018-05-08T05:50:57.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><blockquote><pre><code>本机数据库名称：mysql密码：123456</code></pre></blockquote><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><blockquote><pre><code>文件路径：/user/local/apache-tomcat-9.0.0.M20账号：root密码：123456</code></pre></blockquote><h2 id="apache列表"><a href="#apache列表" class="headerlink" title="apache列表"></a>apache列表</h2><blockquote><pre><code>文件路径 /Users/vd/WebSite</code></pre></blockquote><h2 id="本地git服务器"><a href="#本地git服务器" class="headerlink" title="本地git服务器"></a>本地git服务器</h2><blockquote></blockquote><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><blockquote><pre><code>1. git下载配置2. 下载giblet相应的文件3. 把下载的文件解压放到 相应的位置 例如：/usr/local/giblet4. 进入data目录 找到defaults.properties打开。大多数 配置项可使用缺省。修改 git.repositoriesFolder=/XXXXX/gitServer/gitRepository 然后找到  server.httpPort，设定http协议的端口号，这个端口号可随意指定。保存。5.启动服务 进入giblet文件 运行 ./gitblit.sh</code></pre></blockquote><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gitblish.png?raw=true" alt=""></p><h2 id="本地SVN服务器"><a href="#本地SVN服务器" class="headerlink" title="本地SVN服务器"></a>本地SVN服务器</h2><h3 id="搭建本地仓库"><a href="#搭建本地仓库" class="headerlink" title="搭建本地仓库"></a>搭建本地仓库</h3><blockquote><pre><code>1. 创建svn repository  svnadmin create /Users/vd/svn/repository   2. 配置用户的权限进入 /Users/vd/svn/repository/conf/目录下存在3个文件：authz、passwd、svnserve.confpasswd 添加账号以及密码authz 配置账号的权限3. 启动svn 服务器svnserve -d -r /Users/vd/svn/repository </code></pre></blockquote><h2 id="MAC-命令"><a href="#MAC-命令" class="headerlink" title="MAC 命令"></a>MAC 命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir 创建目录</span><br></pre></td></tr></table></figure><h1 id="软件使用记录"><a href="#软件使用记录" class="headerlink" title="软件使用记录"></a>软件使用记录</h1><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><h3 id="创建本地服务器"><a href="#创建本地服务器" class="headerlink" title="创建本地服务器"></a>创建本地服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安装npm install -g live-server或者cnpm install live-server -gf </span><br><span class="line">再运行live-server就可以在http://127.0.0.1:8080访问</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MAC&quot;&gt;&lt;a href=&quot;#MAC&quot; class=&quot;headerlink&quot; title=&quot;MAC&quot;&gt;&lt;/a&gt;MAC&lt;/h1&gt;&lt;h2 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h
      
    
    </summary>
    
      <category term="mac" scheme="http://yoursite.com/categories/mac/"/>
    
    
  </entry>
  
  <entry>
    <title>demo2</title>
    <link href="http://yoursite.com/2018/05/07/demo2/"/>
    <id>http://yoursite.com/2018/05/07/demo2/</id>
    <published>2018-05-07T12:17:14.000Z</published>
    <updated>2018-05-08T02:57:27.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sdfsdf"><a href="#sdfsdf" class="headerlink" title="sdfsdf"></a>sdfsdf</h1><h2 id="fdsfsdfsdf"><a href="#fdsfsdfsdf" class="headerlink" title="fdsfsdfsdf"></a>fdsfsdfsdf</h2><h3 id="fdfdfdfdfdf"><a href="#fdfdfdfdfdf" class="headerlink" title="fdfdfdfdfdf"></a>fdfdfdfdfdf</h3><p><a href="http://www.baidu.com" target="_blank" rel="noopener">图片</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int demo&#123;</span><br><span class="line"> System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>name</th><th>page</th></tr></thead><tbody><tr><td>dsf</td><td>dfd</td></tr></tbody></table><blockquote><p>sdfsdf<br>fsdfsdf<br>sfsdfsdf</p><p>fsdfsdfsdfsdf<br><a href="https://google.com/" target="_blank" rel="noopener">https://google.com/</a></p></blockquote><p><del>sdfsdf</del><br><del>删除</del></p><p><em>dfdf</em><br><strong>dfd</strong><br><strong><em>dsfsdf</em></strong></p><p><del>删除线</del></p><blockquote><pre><code>1 dfsfdf       fdsfsdfsdf. 2 dsfsdfsdfsdfsdffdsfsfdfsdfsdfsfsdf1 dfsfdf       fdsfsdfsdf. 2 dsfsdfsdfsdfsdffdsfsfdfsdfsdfsfsdf</code></pre></blockquote><table><thead><tr><th>fsfsdf</th><th>sdfsdf</th><th>sdfsdf</th></tr></thead><tbody><tr><td>fsdfsdf</td><td>fsdfsdf</td><td>sdfsdfsdfsfsdfsdfs</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public  int main()&#123;</span><br><span class="line"> System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># A comment</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>～～dsadsa～～</p><p><del>dsadasd</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">e=&gt;End</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">inp=&gt;Input</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;inp-&gt;op</span><br></pre></td></tr></table></figure><font> fdfdfd</font><p>\begin{aligned}?-?\ a=\dfrac {w}{t}\end{aligned}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sdfsdf&quot;&gt;&lt;a href=&quot;#sdfsdf&quot; class=&quot;headerlink&quot; title=&quot;sdfsdf&quot;&gt;&lt;/a&gt;sdfsdf&lt;/h1&gt;&lt;h2 id=&quot;fdsfsdfsdf&quot;&gt;&lt;a href=&quot;#fdsfsdfsdf&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="dd" scheme="http://yoursite.com/categories/dd/"/>
    
    
  </entry>
  
  <entry>
    <title>IOS-Audio</title>
    <link href="http://yoursite.com/2018/05/07/IOS-Audio/"/>
    <id>http://yoursite.com/2018/05/07/IOS-Audio/</id>
    <published>2018-05-07T00:58:58.000Z</published>
    <updated>2018-05-07T01:33:22.308Z</updated>
    
    <content type="html"><![CDATA[<pre><code>IOS-AuidoUnit# demo</code></pre><p> 1.</p><p> 2.</p><p> 3.</p><p>###有序列表</p><p>#这是一级标题</p><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;IOS-AuidoUnit
# demo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 1.&lt;/p&gt;
&lt;p&gt; 2.&lt;/p&gt;
&lt;p&gt; 3.&lt;/p&gt;
&lt;p&gt;###有序列表&lt;/p&gt;
&lt;p&gt;#这是一级标题&lt;/p&gt;
&lt;h2 id=&quot;这是二级标题&quot;&gt;&lt;a href=&quot;#这是二级标题
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
</feed>
