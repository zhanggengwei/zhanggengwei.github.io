<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blogs</title>
  
  <subtitle>张庚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-10T02:45:20.983Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhanggeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP-协议详解-应用</title>
    <link href="http://yoursite.com/2018/07/09/HTTP-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3-%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/09/HTTP-协议详解-应用/</id>
    <published>2018-07-09T01:34:51.000Z</published>
    <updated>2018-07-10T02:45:20.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p> 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器<br> HTTP协议，即超文本传输协议(Hypertext transfer protocol)。是一种详细规定了浏览器和万维网(WWW = World Wide Web)服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。<br>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。<br>HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。<br>在Internet中所有的传输都是通过TCP/IP进行的。HTTP协议作为TCP/IP模型中应用层的协议也不例外。HTTP协议通常承载于TCP协议之上，有时也承载于TLS或SSL协议层之上，这个时候，就成了我们常说的HTTPS。如下图所示：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-request-custom.png?raw=true" alt=""><br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-ssl.png?raw=true" alt=""><br>HTTP默认的端口号为80，HTTPS的端口号为443。<br>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HTTP协议永远都是客户端发起请求，服务器回送响应。这样就限制了使用HTTP协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。<br>HTTP协议的主要特点可概括如下：<br>1、支持客户/服务器模式。支持基本认证和安全认证。<br>2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4、HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP 1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。<br>5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。</p><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>协议的状态是指下一次传输可以“记住”这次传输信息的能力。<br>http是不会为了下一次连接而维护这次连接所传输的信息,为了保证服务器内存。<br>比如客户获得一张网页之后关闭浏览器，然后再一次启动浏览器，再登陆该网站，但是服务器并不知道客户关闭了一次浏览器。<br>由于Web服务器要面对很多浏览器的并发访问，为了提高Web服务器对并发访问的处理能力，在设计HTTP协议时规定Web服务器发送HTTP应答报文和文档时，不保存发出请求的Web浏览器进程的任何状态信息。这有可能出现一个浏览器在短短几秒之内两次访问同一对象时，服务器进程不会因为已经给它发过应答报文而不接受第二期服务请求。由于Web服务器不保存发送请求的Web浏览器进程的任何信息，因此HTTP协议属于无状态协议（Stateless Protocol）。<br>HTTP协议是无状态的和Connection: keep-alive的区别： 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>一次HTTP操作称为一个事务，其工作过程可分为四步：<br>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。<br>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。<br>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-proxy.png?raw-true" alt=""><br><img src="" alt=""></p><p>HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。下图所示TCP连接的三次握手。 在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之间并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。</p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-request.png?raw=true" alt=""></p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /images/logo.gif HTTP/1.1</span><br></pre></td></tr></table></figure><p>表示从/images目录下请求logo.gif这个文件。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>GET<br>POST<br>PUT<br>DELETE<br>TRACE<br>CONNECT<br>PATCH</p><h4 id="GET和POST的区别："><a href="#GET和POST的区别：" class="headerlink" title="GET和POST的区别："></a>GET和POST的区别：</h4><p> 1、GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中。 2、GET提交的数据大小有限制，最多只能有1024字节（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。 3、GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 4、GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</p><h3 id="消息报头"><a href="#消息报头" class="headerlink" title="消息报头"></a>消息报头</h3><table><thead><tr><th>字段名称</th><th>描述</th></tr></thead><tbody><tr><td>If-Modified-Since</td><td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。</td></tr><tr><td>If-None-Match</td><td>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能。例如: If-None-Match: “03f2b33c0bfcc1:0”。</td></tr><tr><td>Pragma</td><td>指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法， 例如： Pragma: no-cache 注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制。缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程）。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage。</td></tr><tr><td>Accept</td><td>浏览器端可以接受的MIME类型。例如：Accept: text/html 代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档，如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。通配符 <em> 代表任意类型，例如 Accept: \</em>/* 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)</td></tr><tr><td>Accept-Encoding</td><td>浏览器申明自己可接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）;Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。例如： Accept-Encoding: gzip, deflate。如果请求消息中没有设置这个域，服务器假定客户端对各种内容编码都可以接受。</td></tr><tr><td>Accept-Language</td><td>浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等；例如：Accept-Language: en-us。如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受</td></tr><tr><td>Accept-Charset</td><td>浏览器可接受的字符集。如果在请求消息中没有设置这个域，缺省表示任何字符集都可以接受</td></tr><tr><td>User-Agent</td><td>告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。例如： User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; CIBA; .NET CLR 2.0.50727; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET4.0C; InfoPath.2; .NET4.0E)。</td></tr><tr><td>Content-Type</td><td>例如：Content-Type: application/x-www-form-urlencoded。</td></tr><tr><td>Referer</td><td>包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="noopener">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></td></tr><tr><td>Connection</td><td>例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。HTTP 1.1默认进行持久连接。利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭，当客户端再次发送Request，需要重新建立TCP连接</td></tr><tr><td>Host</td><td>发送请求时，该头域是必需的）主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。HTTP/1.1请求必须包含主机头域，否则系统会以400状态码返回。例如: 我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html，浏览器发送的请求消息中，就会包含Host请求头域：Host：http://www.guet.edu.cn，此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号。" target="_blank" rel="noopener">http://www.guet.edu.cn/index.html，浏览器发送的请求消息中，就会包含Host请求头域：Host：http://www.guet.edu.cn，此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号。</a></td></tr><tr><td>Cookie</td><td>最重要的请求头之一, 将cookie的值发送给HTTP服务器</td></tr><tr><td>Content-Length</td><td>表示请求消息正文的长度。例如：Content-Length: 38。</td></tr><tr><td>Authorization</td><td>授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</td></tr><tr><td>From</td><td>请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</td></tr><tr><td>Range</td><td>可以请求实体的一个或者多个子范围。例如表示头500个字节：bytes=0-499 表示第二个500字节：bytes=500-999表示最后500个字节：bytes=-500表示500字节以后的范围：bytes=500-第一个和最后一个字节：bytes=0-0,-1同时指定几个范围：bytes=500-600,601-999但是服务器可以忽略此请求头，如果无条件GET包含Range请求头，响应会以状态码206（PartialContent）返回而不是以200（OK）</td></tr></tbody></table><h3 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h3><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-response.png?raw=true" alt=""></p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><h3 id="消息报头-1"><a href="#消息报头-1" class="headerlink" title="消息报头"></a>消息报头</h3><table><thead><tr><th>字段名称</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>服务器支持哪些请求方法（如GET、POST等）。</td></tr><tr><td>Date</td><td>表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦</td></tr><tr><td>Expires</td><td>指明应该在什么时候认为文档已经过期，从而不再缓存它，重新从服务器获取，会更新缓存。过期之前使用本地缓存。HTTP1.1的客户端和缓存会将非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以将Expires实体报头域，设置为0。例如: Expires: Tue, 08 Feb 2022 11:35:14 GMT</td></tr><tr><td>P3P</td><td>用于跨域设置Cookie, 这样可以解决iframe跨域访问cookie的问题</td></tr><tr><td>Set-Cookie</td><td>非常重要的header, 用于把cookie发送到客户端浏览器，每一个写入cookie都会生成一个Set-Cookie</td></tr><tr><td>ETag</td><td>和If-None-Match 配合使用。</td></tr><tr><td>Last-Modified</td><td>用于指示资源的最后修改日期和时间。Last-Modified也可用setDateHeader方法来设置</td></tr><tr><td>Content-Type</td><td>WEB服务器告诉浏览器自己响应的对象的类型和字符集</td></tr><tr><td>Content-Range</td><td>用于指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。一般格式：Content-Range:bytes-unitSPfirst-byte-pos-last-byte-pos/entity-length。例如，传送头500个字节次字段的形式：Content-Range:bytes0-499/1234如果一个http消息包含此节（例如，对范围请求的响 应或对一系列范围的重叠请求），Content-Range表示传送的范围。</td></tr><tr><td>Content-Length</td><td>指明实体正文的长度，以字节方式存储的十进制数字来表示。在数据下行的过程中，Content-Length的方式要预先在服务器中缓存所有数据，然后所有数据再一股脑儿地发给客户端。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</td></tr><tr><td>Content-Encoding</td><td>WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</td></tr><tr><td>Content-Language</td><td>WEB服务器告诉浏览器自己响应的对象所用的自然语言。例如： Content-Language:da。没有设置该域则认为实体内容将提供给所有的语言阅读。</td></tr><tr><td>Server</td><td>指明HTTP服务器用来处理请求的软件信息。例如：Server: Microsoft-IIS/7.5、Server：Apache-Coyote/1.1。此域能包含多个产品标识和注释，产品标识一般按照重要性排序。</td></tr><tr><td>X-AspNet-Version</td><td>如果网站是用ASP.NET开发的，这个header用来表示ASP.NET的版本。</td></tr><tr><td>X-Powered-By</td><td>表示网站是用什么技术开发的。</td></tr><tr><td>Connection</td><td>Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。</td></tr><tr><td>Location</td><td>用于重定向一个新的位置，包含新的URL地址。表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。Location响应报头域常用在更换域名的时候</td></tr><tr><td>Refresh</td><td>表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的" target="_blank" rel="noopener">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的</a><meta http-equiv="Refresh" content="5;URL=http://host/path">实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<meta http-equiv="Refresh" ...="">。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它</td></tr><tr><td>WWW-Authenticate</td><td>该响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域</td></tr></tbody></table><h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><h2 id="文件上传报文"><a href="#文件上传报文" class="headerlink" title="文件上传报文"></a>文件上传报文</h2><h2 id="文件下载的报文"><a href="#文件下载的报文" class="headerlink" title="文件下载的报文"></a>文件下载的报文</h2><h3 id="Content-type"><a href="#Content-type" class="headerlink" title="Content-type"></a>Content-type</h3><p>### </p><h2 id="缓存的实现原理"><a href="#缓存的实现原理" class="headerlink" title="缓存的实现原理"></a>缓存的实现原理</h2><p>WEB缓存(cache)位于Web服务器和客户端之间。<br>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。<br>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作</p><h3 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h3><p>WEB缓存(cache)位于Web服务器和客户端之间。<br>缓存会根据请求保存输出内容的副本，例如html页面，图片，文件，当下一个请求来到的时候：如果是相同的URL，缓存直接使用副本响应访问请求，而不是向源服务器再次发送请求。<br>HTTP协议定义了相关的消息头来使WEB缓存尽可能好的工作。</p><h3 id="客户端缓存生效的常见流程"><a href="#客户端缓存生效的常见流程" class="headerlink" title="客户端缓存生效的常见流程"></a>客户端缓存生效的常见流程</h3><p>服务器收到请求时，会在200OK中回送该资源的Last-Modified和ETag头，客户端将该资源保存在cache中，并记录这两个属性。当客户端需要发送相同的请求时，会在请求中携带If-Modified-Since和If-None-Match两个头。两个头的值分别是响应中Last-Modified和ETag头的值。服务器通过这两个头判断本地资源未发生变化，客户端不需要重新下载，返回304响应。</p><h3 id="Web缓存机制"><a href="#Web缓存机制" class="headerlink" title="Web缓存机制"></a>Web缓存机制</h3><p>HTTP/1.1中缓存的目的是为了在很多情况下减少发送请求，同时在许多情况下可以不需要发送完整响应。前者减少了网络回路的数量；HTTP利用一个“过期（expiration）”机制来为此目的。后者减少了网络应用的带宽；HTTP用“验证（validation）”机制来为此目的。<br>HTTP定义了3种缓存机制：<br>1）Freshness：允许一个回应消息可以在源服务器不被重新检查，并且可以由服务器和客户端来控制。例如，Expires回应头给了一个文档不可用的时间。Cache-Control中的max-age标识指明了缓存的最长时间；<br>2）Validation：用来检查以一个缓存的回应是否仍然可用。例如，如果一个回应有一个Last-Modified回应头，缓存能够使用If-Modified-Since来判断是否已改变，以便判断根据情况发送请求；<br>3）Invalidation：在另一个请求通过缓存的时候，常常有一个副作用。例如，如果一个URL关联到一个缓存回应，但是其后跟着POST、PUT和DELETE的请求的话，缓存就会过期。</p><h2 id="HTTP应用"><a href="#HTTP应用" class="headerlink" title="HTTP应用"></a>HTTP应用</h2><h3 id="断点续传的实现原理"><a href="#断点续传的实现原理" class="headerlink" title="断点续传的实现原理"></a>断点续传的实现原理</h3><p>HTTP协议的GET方法，支持只请求某个资源的某一部分；<br>206 Partial Content 部分内容响应；<br>Range 请求的资源范围；<br>Content-Range 响应的资源范围；<br>在连接断开重连时，客户端只请求该资源未下载的部分，而不是重新请求整个资源，来实现断点续传。<br>分块请求资源实例：<br>Eg1：Range: bytes=306302- ：请求这个资源从306302个字节到末尾的部分；<br>Eg2：Content-Range: bytes 306302-604047/604048：响应中指示携带的是该资源的第306302-604047的字节，该资源共604048个字节；<br>客户端通过并发的请求相同资源的不同片段，来实现对某个资源的并发分块下载。从而达到快速下载的目的。目前流行的FlashGet和迅雷基本都是这个原理。</p><h3 id="多线程下载的原理"><a href="#多线程下载的原理" class="headerlink" title="多线程下载的原理"></a>多线程下载的原理</h3><p>下载工具开启多个发出HTTP请求的线程；<br>每个http请求只请求资源文件的一部分：Content-Range: bytes 20000-40000/47000；<br>合并每个线程下载的文件。</p><h3 id="http代理"><a href="#http代理" class="headerlink" title="http代理"></a>http代理</h3><p>http代理服务器<br>代理服务器英文全称是Proxy Server，其功能就是代理网络用户去取得网络信息。形象的说：它是网络信息的中转站。<br>代理服务器是介于浏览器和Web服务器之间的一台服务器，有了它之后，浏览器不是直接到Web服务器去取回网页而是向代理服务器发出请求，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。<br>而且，大部分代理服务器都具有缓冲的功能，就好象一个大的Cache，它有很大的存储空间，它不断将新取得数据储存到它本机的存储器上，如果浏览器所请求的数据在它本机的存储器上已经存在而且是最新的，那么它就不重新从Web服务器取数据，而直接将存储器上的数据传送给用户的浏览器，这样就能显著提高浏览速度和效率。更重要的是：Proxy Server(代理服务器)是Internet链路级网关所提供的一种重要的安全功能，它的工作主要在开放系统互联(OSI)模型的对话层。<br>http代理服务器的主要功能：<br>1）突破自身IP访问限制，访问国外站点。如：教育网、169网等网络用户可以通过代理访问国外网站；<br>2）访问一些单位或团体内部资源，如某大学FTP(前提是该代理地址在该资源的允许访问范围之内)，使用教育网内地址段免费代理服务器，就可以用于对教育 网开放的各类FTP下载上传，以及各类资料查询共享等服务；<br>3）突破中国电信的IP封锁：中国电信用户有很多网站是被限制访问的，这种限制是人为的，不同Serve对地址的封锁是不同的。所以不能访问时可以换一个国外的代理服务器试试；<br>4）提高访问速度：通常代理服务器都设置一个较大的硬盘缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度；<br>5）隐藏真实IP：上网者也可以通过这种方法隐藏自己的IP，免受攻击。<br>对于客户端浏览器而言，http代理服务器相当于服务器。<br>而对于Web服务器而言，http代理服务器又担当了客户端的角色。</p><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>虚拟主机：是在网络服务器上划分出一定的磁盘空间供用户放置站点、应用组件等，提供必要的站点功能与数据存放、传输功能。<br>所谓虚拟主机，也叫“网站空间”就是把一台运行在互联网上的服务器划分成多个“虚拟”的服务器，每一个虚拟主机都具有独立的域名和完整的Internet服务器（支持WWW、FTP、E-mail等）功能。一台服务器上的不同虚拟主机是各自独立的，并由用户自行管理。但一台服务器主机只能够支持一定数量的虚拟主机，当超过这个数量时，用户将会感到性能急剧下降。<br>虚拟主机的实现原理<br>虚拟主机是用同一个WEB服务器，为不同域名网站提供服务的技术。Apache、Tomcat等均可通过配置实现这个功能。<br>相关的HTTP消息头：Host。<br>例如：Host: <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>客户端发送HTTP请求的时候，会携带Host头，Host头记录的是客户端输入的域名。这样服务器可以根据Host头确认客户要访问的是哪一个域名。 </p><h2 id="HTTP认证方式"><a href="#HTTP认证方式" class="headerlink" title="HTTP认证方式"></a>HTTP认证方式</h2><p>HTTP请求报头： Authorization<br>HTTP响应报头： WWW-Authenticate<br>HTTP认证是基于质询/回应(challenge/response)的认证模式。</p><h3 id="基本认证"><a href="#基本认证" class="headerlink" title="基本认证"></a>基本认证</h3><h3 id="HTTP-OAuth认证"><a href="#HTTP-OAuth认证" class="headerlink" title="HTTP OAuth认证"></a>HTTP OAuth认证</h3><p>基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式。<br>把 “用户名+冒号+密码”用BASE64算法加密后的字符串放在http request 中的header Authorization中发送给服务端。<br>客户端对于每一个realm，通过提供用户名和密码来进行认证的方式。<br>包含密码的明文传递。<br>当浏览器访问使用基本认证的网站的时候， 浏览器会提示你输入用户名和密码，如下图：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-auth.jpg?raw=true" alt=""><br>假如用户名密码错误的话，服务器会返回401，如下图：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-auth-error.jpg?raw=true" alt=""><br>基本认证步骤：</p><h3 id="digest-authentication（HTTP1-1提出的基本认证的替代方法）"><a href="#digest-authentication（HTTP1-1提出的基本认证的替代方法）" class="headerlink" title="digest authentication（HTTP1.1提出的基本认证的替代方法）"></a>digest authentication（HTTP1.1提出的基本认证的替代方法）</h3><p>这个认证可以看做是基本认证的增强版本，不包含密码的明文传递。<br>引入了一系列安全增强的选项；“保护质量”(qop)、随机数计数器由客户端增加、以及客户生成的随机数。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-digest.jpg?raw=true" alt=""><br>在HTTP摘要认证中使用 MD5 加密是为了达成”不可逆的”，也就是说，当输出已知的时候，确定原始的输入应该是相当困难的。如果密码本身太过简单，也许可以<br>通过尝试所有可能的输入来找到对应的输出（穷举攻击），甚至可以通过字典或者适当的查找表加快查找速度。</p><h4 id="示例及说明"><a href="#示例及说明" class="headerlink" title="示例及说明"></a>示例及说明</h4><p>典型的认证过程包括如下步骤<br>客户端请求一个需要认证的页面，但是不提供用户名和密码。通常这是由于用户简单的输入了一个地址或者在页面中点击了某个超链接。<br>服务器返回401 “Unauthorized” 响应代码，并提供认证域(realm)，以及一个随机生成的、只使用一次的数值，称为密码随机数 nonce。<br>此时，浏览器会向用户提示认证域(realm)（通常是所访问的计算机或系统的描述），并且提示用户名和密码。用户此时可以选择取消。<br>一旦提供了用户名和密码，客户端会重新发送同样的请求，但是添加了一个认证头包括了响应代码。<br>注意：客户端可能已经拥有了用户名和密码，因此不需要提示用户，比如以前存储在浏览器里的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端请求 (无认证)：</span><br><span class="line">GET /dir/index.html HTTP/1.0</span><br><span class="line">Host: localhost</span><br><span class="line">(跟随一个新行，形式为一个回车再跟一个换行）</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">服务器响应：</span><br><span class="line">HTTP/1.0 401 Unauthorized</span><br><span class="line">Server: HTTPd/0.9</span><br><span class="line">Date: Sun, 10 Apr 2005 20:26:47 GMT</span><br><span class="line">WWW-Authenticate: Digest realm=&quot;testrealm@host.com&quot;,   //认证域</span><br><span class="line">                        qop=&quot;auth,auth-int&quot;,   //保护质量</span><br><span class="line">                        nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;,  //服务器密码随机数</span><br><span class="line">                        opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot;</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 311</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span><br><span class="line"> &quot;http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd&quot;&gt;</span><br><span class="line">&lt;HTML&gt;</span><br><span class="line">  &lt;HEAD&gt;</span><br><span class="line">    &lt;TITLE&gt;Error&lt;/TITLE&gt;</span><br><span class="line">    &lt;META HTTP-EQUIV=&quot;Content-Type&quot; CONTENT=&quot;text/html; charset=ISO-8859-1&quot;&gt;</span><br><span class="line">  &lt;/HEAD&gt;</span><br><span class="line">  &lt;BODY&gt;&lt;H1&gt;401 Unauthorized.&lt;/H1&gt;&lt;/BODY&gt;</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">客户端请求 (用户名 &quot;Mufasa&quot;, 密码 &quot;Circle Of Life&quot;)：</span><br><span class="line">GET /dir/index.html HTTP/1.0</span><br><span class="line">Host: localhost</span><br><span class="line">Authorization: Digest username=&quot;Mufasa&quot;,</span><br><span class="line">                     realm=&quot;testrealm@host.com&quot;,</span><br><span class="line">                     nonce=&quot;dcd98b7102dd2f0e8b11d0f600bfb0c093&quot;,</span><br><span class="line">                     uri=&quot;/dir/index.html&quot;,</span><br><span class="line">                     qop=auth,</span><br><span class="line">                     nc=00000001,    //请求计数</span><br><span class="line">                     cnonce=&quot;0a4f113b&quot;,   //客户端密码随机数</span><br><span class="line">                     response=&quot;6629fae49393a05397450978507c4ef1&quot;,</span><br><span class="line">                     opaque=&quot;5ccc069c403ebaf9f0171e9517f40e41&quot;</span><br><span class="line">(跟随一个新行，形式如前所述)。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务器响应：</span><br><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Server: HTTPd/0.9</span><br><span class="line">Date: Sun, 10 Apr 2005 20:27:03 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 7984</span><br><span class="line">(随后是一个空行，然后是所请求受限制的HTML页面)</span><br></pre></td></tr></table></figure><p>response 值由三步计算而成。当多个数值合并的时候，使用冒号作为分割符：</p><p>1、对用户名、认证域(realm)以及密码的合并值计算 MD5 哈希值，结果称为 HA1。<br>2、对HTTP方法以及URI的摘要的合并值计算 MD5 哈希值，例如，”GET” 和 “/dir/index.html”，结果称为 HA2。<br>3、对HA1、服务器密码随机数(nonce)、请求计数(nc)、客户端密码随机数(cnonce)、保护质量(qop)以及 HA2 的合并值计算 MD5 哈希值。结果即为客户端提供的<br>response 值。<br>因为服务器拥有与客户端同样的信息，因此服务器可以进行同样的计算，以验证客户端提交的 response 值的正确性。在上面给出的例子中，结果是如下计算的。<br>（MD5()表示用于计算MD5哈希值的函数；“\”表示接下一行；引号并不参与计算）<br>HA1 = MD5( “Mufasa:<a href="mailto:testrealm@host.com" target="_blank" rel="noopener">testrealm@host.com</a>:Circle Of Life” )<br>       = 939e7578ed9e3c518a452acee763bce9<br>HA2 = MD5( “GET:/dir/index.html” )<br>       = 39aff3a2bab6126f332b942af96d3366<br>Response = MD5( “939e7578ed9e3c518a452acee763bce9:\<br>                         dcd98b7102dd2f0e8b11d0f600bfb0c093:\<br>00000001:0a4f113b:auth:\<br>39aff3a2bab6126f332b942af96d3366” )<br>= 6629fae49393a05397450978507c4ef1</p><p>此时客户端可以提交一个新的请求，重复使用服务器密码随机数(nonce)（服务器仅在每次“401”响应后发行新的nonce），但是提供新的客户端密码随机数(cnonce)。在后续的请求中，十六进制请求计数器(nc)必须比前一次使用的时候要大，否则攻击者可以简单的使用同样的认证信息重放老的请求。由服务器来确保在每个发出的密码随机数nonce时，计数器是在增加的，并拒绝掉任何错误的请求。显然，改变HTTP方法和/或计数器数值都会导致不同的 response值。<br>服务器应当记住最近所生成的服务器密码随机数nonce的值。也可以在发行每一个密码随机数nonce后，记住过一段时间让它们过期。如果客户端使用了一个过期的值，服务器应该响应“401”状态号，并且在认证头中添加stale=TRUE，表明客户端应当使用新提供的服务器密码随机数nonce重发请求，而不必提示用户其它用户名和口令。<br>服务器不需要保存任何过期的密码随机数，它可以简单的认为所有不认识的数值都是过期的。服务器也可以只允许每一个服务器密码随机数nonce使用一次，当然，这样就会迫使客户端在发送每个请求的时候重复认证过程。需要注意的是，在生成后立刻过期服务器密码随机数nonce是不行的，因为客户端将没有任何机会来使用这个nonce。</p><h2 id="HTTPS传输协议原理"><a href="#HTTPS传输协议原理" class="headerlink" title="HTTPS传输协议原理"></a>HTTPS传输协议原理</h2><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容请看SSL。</p><h3 id="两种基本的加解密算法类型"><a href="#两种基本的加解密算法类型" class="headerlink" title="两种基本的加解密算法类型"></a>两种基本的加解密算法类型</h3><p>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等。<br>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等</p><h3 id="HTTPS通信过程"><a href="#HTTPS通信过程" class="headerlink" title="HTTPS通信过程"></a>HTTPS通信过程</h3><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/HTTP/http-https.png?raw=true" alt=""></p><h3 id="HTTPS通信的优点"><a href="#HTTPS通信的优点" class="headerlink" title="HTTPS通信的优点"></a>HTTPS通信的优点</h3><p>客户端产生的密钥只有客户端和服务器端能得到；<br>加密的数据只有客户端和服务器端才能得到明文；<br>客户端到服务端的通信是安全的。</p><h2 id="http的状态响应码"><a href="#http的状态响应码" class="headerlink" title="http的状态响应码"></a>http的状态响应码</h2><p>###信息类：<br>表示接收到请求并且继续处理<br>100——客户必须继续发出请求<br>101——客户要求服务器根据请求转换HTTP协议版本</p><h3 id="响应成功："><a href="#响应成功：" class="headerlink" title="响应成功："></a>响应成功：</h3><p>表示动作被成功接收、理解和接受<br>200——表明该请求被成功地完成，所请求的资源发送回客户端<br>201——提示知道新文件的URL<br>202——接受和处理、但处理未完成<br>203——返回信息不确定或不完整<br>204——请求收到，但返回信息为空<br>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br>206——服务器已经完成了部分用户的GET请求</p><h3 id="重定向类："><a href="#重定向类：" class="headerlink" title="重定向类："></a>重定向类：</h3><p>为了完成指定的动作，必须接受进一步处理<br>300——请求的资源可在多处得到<br>301——本网页被永久性转移到另一个URL<br>302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。<br>303——建议客户访问其他URL或访问方式<br>304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用<br>305——请求的资源必须从服务器指定的地址得到<br>306——前一版本HTTP中使用的代码，现行版本中不再使用<br>307——申明请求的资源临时性删除</p><h3 id="客户端错误类："><a href="#客户端错误类：" class="headerlink" title="客户端错误类："></a>客户端错误类：</h3><p>请求包含错误语法或不能正确执行<br>400——客户端请求有语法错误，不能被服务器所理解<br>401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>HTTP 401.1 - 未授权：登录失败<br>　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败<br>　　HTTP 401.3 - ACL 禁止访问资源<br>　　HTTP 401.4 - 未授权：授权被筛选器拒绝<br>HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败<br>402——保留有效ChargeTo头响应<br>403——禁止访问，服务器收到请求，但是拒绝提供服务</p><h4 id="HTTP-403-1"><a href="#HTTP-403-1" class="headerlink" title="HTTP 403.1"></a>HTTP 403.1</h4><p>禁止访问：禁止可执行访问<br>HTTP 403.2 - 禁止访问：禁止读访问<br>HTTP 403.3 - 禁止访问：禁止写访问<br>HTTP 403.4 - 禁止访问：要求 SSL<br>HTTP 403.5 - 禁止访问：要求 SSL 128<br>HTTP 403.6 - 禁止访问：IP 地址被拒绝<br>HTTP 403.7 - 禁止访问：要求客户证书<br>HTTP 403.8 - 禁止访问：禁止站点访问<br>HTTP 403.9 - 禁止访问：连接的用户过多<br>HTTP 403.10 - 禁止访问：配置无效<br>HTTP 403.11 - 禁止访问：密码更改<br>HTTP 403.12 - 禁止访问：映射器拒绝访问<br>HTTP 403.13 - 禁止访问：客户证书已被吊销<br>HTTP 403.15 - 禁止访问：客户访问许可过多<br>HTTP 403.16 - 禁止访问：客户证书不可信或者无效<br>HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效</p><p>404 一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL<br>405 用户在Request-Line字段定义的方法不允许<br>406 根据用户发送的Accept拖，请求资源不可访问<br>407 类似401，用户必须首先在代理服务器上得到授权<br>408 客户端没有在用户指定的饿时间内完成请求<br>409 对当前资源状态，请求不能完成<br>410 服务器上不再有此资源且无进一步的参考地址<br>411 服务器拒绝用户定义的Content-Length属性请求<br>412 一个或多个请求头字段在当前请求中错误<br>413 请求的资源大于服务器允许的大小<br>414 请求的资源URL长于服务器允许的长度<br>415 请求资源不支持请求项目格式<br>416 请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段<br>417 服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</p><h3 id="5-服务端错误类："><a href="#5-服务端错误类：" class="headerlink" title="5**服务端错误类："></a>5**服务端错误类：</h3><p>服务器不能正确执行一个正确的请求<br>服务器遇到错误，无法完成请求<br>HTTP 500.100 - 内部服务器错误 - ASP 错误<br>HTTP 500-11 服务器关闭<br>HTTP 500-12 应用程序重新启动<br>HTTP 500-13 - 服务器太忙<br>HTTP 500-14 - 应用程序无效<br>HTTP 500-15 - 不允许请求 global.asa<br>Error 501 - 未实现<br>HTTP 502 - 网关错误<br>HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤</p><p>1、客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn。" target="_blank" rel="noopener">http://www.oakcms.cn。</a></p><p>2、发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p><p>3、服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p><p>4、释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;<br>5、客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HTTP协议&quot;&gt;&lt;a href=&quot;#HTTP协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP协议&quot;&gt;&lt;/a&gt;HTTP协议&lt;/h1&gt;&lt;p&gt; 协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种
      
    
    </summary>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>socket-详解</title>
    <link href="http://yoursite.com/2018/07/05/socket-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/07/05/socket-详解/</id>
    <published>2018-07-05T01:39:12.000Z</published>
    <updated>2018-07-05T02:30:27.821Z</updated>
    
    <content type="html"><![CDATA[<p>侧重于函数的的应用</p><h1 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h1><h2 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int socket(int domain,int type,int protocol)</span><br><span class="line">返回0代表socket创建成功,-1socket创建失败</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>domain</td><td>地址族</td></tr><tr><td>type</td><td>套接字的数据类型</td></tr><tr><td>protocol</td><td>协议（跟type有关）</td></tr></tbody></table><table><thead><tr><th>domain</th><th>含义</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4协议</td></tr><tr><td>AF_INET6</td><td>IPv6协议</td></tr><tr><td>AF_LOCAL</td><td>Unix域协议</td></tr><tr><td>AF_ROUTE</td><td>路由套接字</td></tr><tr><td>AF_KEY</td><td>密钥套接字</td></tr></tbody></table><table><thead><tr><th>protocol</th><th>含义</th></tr></thead><tbody><tr><td>IPPROTO_TCP</td><td>TCP传输协议</td></tr><tr><td>IPPROTO_UDP</td><td>UDP传输协议</td></tr><tr><td>IPPROTO_SCTP</td><td>SCTP传输协议</td></tr></tbody></table><table><thead><tr><th>type</th><th>含义</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>字节流套接字</td></tr><tr><td>SOCK_DGRAM</td><td>数据报套接字</td></tr><tr><td>SOCK_SEQPACKET</td><td>有序分组套接字</td></tr><tr><td>SOCK_RAW</td><td>原始套接字</td></tr></tbody></table><h2 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair"></a>socketpair</h2><p>使用socketpiar创建的是一对相互连接的socket，任意一段既可以做发送，也可以做接受端。所有每个socket描述符中应该有两个buf。一个为发送buf，一个为接受buf。如上图所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">注意:  socketpair创建的只适用于父子进程或者线程间通信，不能用于两个进程之间通信。如果要实现两个进程之间的双向通信，则需要将socketpair创建的一个描述符fd发送给另一个进程，这相当于两个两个不同的进程访问同一个文件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## getsockopt setsockopt</span><br><span class="line">获得socket属性</span><br></pre></td></tr></table></figure><p>int getsockopt(int sockfd, int level, int name, char <em>value, int </em>optlen);<br>int setsockopt(int sockfd, int level, int name, char <em>value, int </em>optlen);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">对于socket编程，level一般为常数SOL_SOCKET</span><br><span class="line">name属性类型，value属性参数，optlen属性内存块的长度</span><br><span class="line">常用的有：</span><br><span class="line"></span><br><span class="line">|optlen|含义|</span><br><span class="line">|----|----|</span><br><span class="line">|SO_RCVTIMEO|设置/获得接收的timeout|</span><br><span class="line">|SO_SNDTIMEO|设置/获得发送的timeout|</span><br><span class="line">|SO_SNDBUF|获得或设置socket发送的buffer大小|</span><br><span class="line">|SO_RCVBUF|获得或设置socket接收的buffer大小|</span><br><span class="line">|SO_BROADCAST|获得或设置socket状况，使之可以广播发送数据报。（只能用于UDP方式）。|</span><br><span class="line">|SO_REUSEADDR|设置该socket绑定的端口可以被重用。|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：在Linux系统中，如果一个socket绑定了某个端口，该socket正常关闭或程序退出后，在一段时间内该端口依然保持被绑定的状态，其他程序（或者重新启动的原程序）无法绑定该端口。可以通过调用以下语句避免该问题</span><br></pre></td></tr></table></figure></p><p>opt = 1; len = sizeof(opt); setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;opt,&amp;len);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## getpeername</span><br><span class="line"></span><br><span class="line">取得对方主机的信息</span><br></pre></td></tr></table></figure></p><p>int getpeername(int sockfd, struct sockaddr <em>addr, int </em>addrlen);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">addr存有返回的主机信息。</span><br></pre></td></tr></table></figure></p><p>示例：<br>struct sockaddr_in sa;<br>int len = sizeof(sa);<br>getpeername(sockfd, (struct sockaddr *)&amp;sa, &amp;len);<br>printf(“对方IP：%s”, inet_ntoa(sa.sin_addr));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## getsockname</span><br><span class="line"></span><br><span class="line">取得本地信息</span><br></pre></td></tr></table></figure></p><p>int getsockname(int sockfd, struct sockaddr <em>addr, int </em>addrlen);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr存有返回的主机信息</span><br></pre></td></tr></table></figure></p><p>struct sockaddr_in sa;<br>int len = sizeof(sa);<br>getpeername(sockfd, (struct sockaddr *)&amp;sa, &amp;len);<br>printf(“本地IP：%s”, inet_ntoa(sa.sin_addr));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## bind</span><br><span class="line"></span><br><span class="line">bind函数把一个本地协议地址赋予一个套接字</span><br></pre></td></tr></table></figure></p><p>int bind(int sockfd,const struct sockaddr *myaddr,socklen_t addrlen)<br>成功返回0 不成功返回-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|参数|含义|</span><br><span class="line">|----|----|</span><br><span class="line">|sockfd|socket(int,int,int) 创建出来的|</span><br><span class="line">|myaddr|服务器地址的指针|</span><br><span class="line">|addrlen|myaddr的长度|</span><br><span class="line"></span><br><span class="line">## connect</span><br><span class="line"></span><br><span class="line">TCP客户用connect函数来建立与TCP服务器的连接.</span><br></pre></td></tr></table></figure></p><p>int connect(int sockfd,const struct sockaddr *servaddr,socklen_t addrlen)<br>成功返回0 不成功返回-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|参数|含义|</span><br><span class="line">|----|----|</span><br><span class="line">|sockfd|socket(int,int,int) 创建出来的|</span><br><span class="line">|servaddr|服务端地址的指针|</span><br><span class="line">|addrlen|servaddr的长度|</span><br><span class="line"></span><br><span class="line">## listen</span><br><span class="line"></span><br><span class="line">当socket函数创建一个套接字时,它被假设为一个主动套接字,也就是说它是一个将调用connect发起连接的客户套接字,listen函数把一个未连接的套接字转换成一个被动套接字,指示内核应接受指向该套接字的连接请求.</span><br></pre></td></tr></table></figure></p><p>int listen(int sockfd,int backlog)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">|参数|含义|</span><br><span class="line">|----|----|</span><br><span class="line">|sockfd|socket(int,int,int) 创建出来的|</span><br><span class="line">|backlog|backlog为相应套接字排队的最大连接个数|</span><br><span class="line"></span><br><span class="line">## accept</span><br><span class="line"></span><br><span class="line">accept函数由TCP服务器调用,用于从一个已完成连接的队列队头返回下一个已完成连接.</span><br></pre></td></tr></table></figure><p>int accept(int sockfd,struct sockaddr <em>cliaddr,socklen_t </em>addrlen)<br>成功返回非负，失败返回-1 返回值就是客户端的套接字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>如果accept成功,那么其返回值是由内核自动生成的一个全新描述符,它的第一个参数为监听套接字描述符,返回值为已连接套接字描述符.一个服务器通常仅仅创建一个监听套接字,它在服务器的生命期内一直存在.内核为每个由服务器进程接受的客户连接创建一个已连接套接字.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## close</span><br><span class="line"></span><br><span class="line">关闭连接将中断对该socket的读写操作。</span><br><span class="line">关闭用于listen()的socket描述符将禁止其他Client的连接请求。</span><br></pre></td></tr></table></figure></p><p>int close(int sockfd);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">## shutdown</span><br><span class="line"></span><br><span class="line">shutdown()函数可以单方面的中断连接，即禁止某个方向的信息传递。</span><br></pre></td></tr></table></figure></p><p>int shutdown(int sockfd, int how);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|参数|含义|</span><br><span class="line">|-----|-----|</span><br><span class="line">|sockfd||</span><br><span class="line">|how|0 - 禁止接收信息1 - 禁止发送信息2 - 接收和发送都被禁止，与close()函数效果相同|</span><br><span class="line"></span><br><span class="line">## gethostbyname</span><br><span class="line"></span><br><span class="line">获得DNS信息：</span><br><span class="line"></span><br><span class="line">## inet_addr</span><br></pre></td></tr></table></figure></p><p>unsigned long inet_addr(const char* cp);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## inet_ntoa</span><br></pre></td></tr></table></figure></p><p>char* inet_ntoa(struct in_addr in);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 获得或改变socket的I/O属性：</span><br><span class="line">### ioctl</span><br><span class="line"> ioctl函数用于在套接字上控制套接字的I/O行为，同时获取与套接字挂起的I/O操作的有关信息</span><br><span class="line"> </span><br><span class="line"> ```</span><br></pre></td></tr></table></figure></p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl"></a>fcntl</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;侧重于函数的的应用&lt;/p&gt;
&lt;h1 id=&quot;socket&quot;&gt;&lt;a href=&quot;#socket&quot; class=&quot;headerlink&quot; title=&quot;socket&quot;&gt;&lt;/a&gt;socket&lt;/h1&gt;&lt;h2 id=&quot;socket-1&quot;&gt;&lt;a href=&quot;#socket-1&quot; cl
      
    
    </summary>
    
      <category term="socket" scheme="http://yoursite.com/categories/socket/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENGL-函数</title>
    <link href="http://yoursite.com/2018/07/02/OPENGL-%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/07/02/OPENGL-函数/</id>
    <published>2018-07-02T07:36:42.000Z</published>
    <updated>2018-07-02T07:52:11.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="glGenRenderbuffers"><a href="#glGenRenderbuffers" class="headerlink" title="glGenRenderbuffers"></a>glGenRenderbuffers</h3><p>void glGenRenderbuffers (GLsizei n, GLuint* renderbuffers);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是创建帧的数目，第二个是指向存储一个或者多个ID的变量或数组的指针</span><br></pre></td></tr></table></figure><h3 id="glBindFramebuffer"><a href="#glBindFramebuffer" class="headerlink" title="glBindFramebuffer"></a>glBindFramebuffer</h3><p>void  glBindFramebuffer (GLenum target, GLuint framebuffer) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个参数target应该是GL_FRAMEBUFFER，第二个参数是FBO的ID号。一旦FBO被绑定，之后的所有的OpenGL操作都会对当前所绑定的FBO造成影响。ID号为0表示缺省帧缓存，即默认的window提供的帧缓存。因此，在glBindFramebuffer()中将ID号设置为0可以解绑定当前FBO。</span><br></pre></td></tr></table></figure><p>一旦一个FBO被创建，在使用它之前必须绑定。</p><h3 id="glDeleteFramebuffers"><a href="#glDeleteFramebuffers" class="headerlink" title="glDeleteFramebuffers"></a>glDeleteFramebuffers</h3><h2 id="渲染缓存对象"><a href="#渲染缓存对象" class="headerlink" title="渲染缓存对象"></a>渲染缓存对象</h2><p>glGenRenderbuffers</p><p>glDeleteRenderbuffers<br>glDeleteRenderbuffers</p><p>glRenderbufferStorage<br>当一个渲染缓存被创建，它没有任何数据存储区域，所以我们还要为他分配空间。这可以通过用glRenderbufferStorage()实现。第一个参数必须是GL_RENDERBUFFER。第二个参数可以是用于颜色的（GL_RGB，GL_RGBA，etc.），用于深度的（GL_DEPTH_COMPONENT），或者是用于模板的格式（GL_STENCIL_INDEX）。Width和height是渲染缓存图像的像素维度。</p><p>width和height必须比GL_MAX_RENDERBUFFER_SIZE_EXT小，否则将会产生GL_UNVALID_VALUE错误。</p><p>glGetRenderbufferParameteriv()<br>void glGetRenderbufferParameteriv(GLenum target, GLenum param,GLint* value);<br>我们也可以得到当前绑定的渲染缓存对象的一些参数。Target应该是GL_RENDERBUFFER，第二个参数是所要得到的参数名字。最后一个是指向存储返回值的整型量的指针。渲染缓存的变量名有如下：<br>GL_RENDERBUFFER_WIDTH<br>GL_RENDERBUFFER_HEIGHT<br>GL_RENDERBUFFER_INTERNAL_FORMAT<br>GL_RENDERBUFFER_RED_SIZE<br>GL_RENDERBUFFER_GREEN_SIZE<br>GL_RENDERBUFFER_BLUE_SIZE<br>GL_RENDERBUFFER_ALPHA_SIZE<br>GL_RENDERBUFFER_DEPTH_SIZE<br>GL_RENDERBUFFER_STENCIL_SIZE</p><p>将图像和FBO关联</p><p>FBO本身没有图像存储区。我们必须帧缓存关联图像（纹理或渲染对象）关联到FBO。这种机制允许FBO快速地切换（分离和关联）帧缓存关联图像。切换帧缓存关联图像比在FBO之间切换要快得多。而且，它节省了不必要的数据拷贝和内存消耗。比如，一个纹理可以被关联到多个FBO上，图像存储区可以被多个FBO共享。<br>把2D纹理图像关联到FBO<br>glFramebufferTexture2D(GLenum target,<br>                          GLenumattachmentPoint,<br>                         GLenum textureTarget,<br>                         GLuint textureId,<br>                         GLint  level)</p><p>glFramebufferTexture2D()把一幅纹理图像关联到一个FBO。第一个参数一定是GL_FRAMEBUFFER_，第二个参数是关联纹理图像的关联点。一个帧缓冲区对象可以有多个颜色关联点(GL_COLOR_ATTACHMENT0, …, GL_COLOR_ATTACHMENTn),L_DEPTH_ATTACHMENT, 和GL_STENCIL_ATTACHMENT。第三个参数textureTarget在多数情况下是GL_TEXTURE_2D。第四个参数是纹理对象的ID号。最后一个参数是要被关联的纹理的mipmap等级<br>如果参数textureId被设置为0，那么纹理图像将会被从FBO分离。如果纹理对象在依然关联在FBO上时被删除，那么纹理对象将会自动从当前帮的FBO上分离。然而，如果它被关联到多个FBO上然后被删除，那么它将只被从绑定的FBO上分离，而不会被从其他非绑定的FBO上分离。</p><p>把渲染缓存对象关联到FBO<br>void glFramebufferRenderbuffer(GLenum target,<br>                                 GLenum attachmentPoint,<br>                                 GLenum renderbufferTarget,<br>                                 GLuint renderbufferId)<br>通过调用glFramebufferRenderbuffer()可以关联渲染缓存图像。前两个参数和glFramebufferTexture2D()一样。第三个参数只能是GL_RENDERBUFFER，最后一个参数是渲染缓存对象的ID号。<br>如果参数renderbufferId被设置为0，渲染缓存图像将会从FBO的关联点分离。如果渲染缓存图像在依然关联在FBO上时被删除，那么纹理对象将会自动从当前绑定的FBO上分离，而不会从其他非绑定的FBO上分离。</p><p>检查FBO状态<br>一旦关联图像（纹理和渲染缓存）被关联到FBO上，在执行FBO的操作之前，你必须检查FBO的状态:完整或不完整。这可以通过调用glCheckFramebufferStatusEXT()来检查其状态。如果帧缓冲区状态是不完整的，那么任何绘制命令(glBegin(),glCopyTexImage2D()等等)都会失败。</p><p>GLenum glCheckFramebufferStatus(GLenum target)</p><p>FBO完整性准则有</p><p>（1）帧缓存关联图像的宽度和高度必须非零。<br>（2）如果一幅图像被关联到一个颜色关联点，那么这幅图像必须有颜色可渲染的内部格式（GL_RGBA, GL_DEPTH_COMPONENT, GL_LUMINANCE, etc)。<br>（3）如果一幅被图像关联到GL_DEPTH_ATTACHMENT，那么这幅图像必须有深度可渲染的内部格式(GL_DEPTH_COMPONENT,GL_DEPTH_COMPONENT24, etc)。<br>（4）如果一幅被图像关联到GL_STENCIL_ATTACHMENT，那么这幅图像必须有模板可渲染的内部格式(GL_STENCIL_INDEX,GL_STENCIL_INDEX8, etc)。<br>（5）FBO至少有一幅图像关联。<br>（6）被关联到FBO的缩影图像必须有相同的宽度和高度。<br>（7）被关联到颜色关联点上的所有图像必须有相同的内部格式。<br>注意：即使以上所有条件都满足，你的OpenGL驱动也可能不支持某些格式和参数的组合。如果一种特别的实现不被OpenGL驱动支持，那么glCheckFramebufferStatus()返回GL_FRAMEBUFFER_UNSUPPORTED。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;h3 id=&quot;glGenRenderbuffers&quot;&gt;&lt;a href=&quot;#glGenRenderbuffers&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>OPENGLES-纹理</title>
    <link href="http://yoursite.com/2018/06/22/OPENGLES-%E7%BA%B9%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/22/OPENGLES-纹理/</id>
    <published>2018-06-22T00:51:51.000Z</published>
    <updated>2018-07-03T07:06:46.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p>我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性</p><p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><p>艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p><h2 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h2><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p><table><thead><tr><th>环绕方式</th><th>描述</th></tr></thead><tbody><tr><td>GL_REPEAT</td><td>对纹理的默认行为。重复纹理图像。</td></tr><tr><td>GL_MIRRORED_REPEAT</td><td>和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td>GL_CLAMP_TO_EDGE</td><td>纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td>GL_CLAMP_TO_BORDER</td><td>超出的坐标为用户指定的边缘颜色</td></tr></tbody></table><p>前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br></pre></td></tr></table></figure><p>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。<br>如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float borderColor[] = &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;</span><br><span class="line">glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</span><br></pre></td></tr></table></figure><h2 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h2><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注1</span><br><span class="line">Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。</span><br></pre></td></tr></table></figure><p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/filter_nearest.png?raw=true" alt=""></p><p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/filter_linear.png?raw=true" alt=""></p><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/texture_filtering.png?raw=true" alt=""></p><p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure><h2 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h2><h2 id="加载与创建纹理"><a href="#加载与创建纹理" class="headerlink" title="加载与创建纹理"></a>加载与创建纹理</h2><p>使用纹理之前要做的第一件事是把它们加载到我们的应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，所以我们如何才能把这些图像加载到应用中呢？一个解决方案是选一个需要的文件格式，比如.PNG，然后自己写一个图像加载器，把图像转化为字节序列。写自己的图像加载器虽然不难，但仍然挺麻烦的，而且如果要支持更多文件格式呢？你就不得不为每种你希望支持的格式写加载器了。</p><h3 id="生成纹理"><a href="#生成纹理" class="headerlink" title="生成纹理"></a>生成纹理</h3><p>和之前生成的OpenGL对象一样，纹理也是使用ID引用的。让我们来创建一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int texture;</span><br><span class="line">glGenTextures(1, &amp;texture);</span><br></pre></td></tr></table></figure><p>glGenTextures函数首先需要输入生成纹理的数量，然后把它们储存在第二个参数的unsigned int数组中（我们的例子中只是单独的一个unsigned int），就像其他对象一样，我们需要绑定它，让之后任何的纹理指令都可以配置当前绑定的纹理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br></pre></td></tr></table></figure><p>现在纹理已经绑定了，我们可以使用前面载入的图片数据生成一个纹理了。纹理可以通过glTexImage2D来生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">glGenerateMipmap(GL_TEXTURE_2D);</span><br></pre></td></tr></table></figure><p>函数很长，参数也不少，所以我们一个一个地讲解：<br>    •    第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。<br>    •    第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。<br>    •    第三个参数告诉OpenGL我们希望把纹理储存为何种格式。我们的图像只有RGB值，因此我们也把纹理储存为RGB值。<br>    •    第四个和第五个参数设置最终的纹理的宽度和高度。我们之前加载图像的时候储存了它们，所以我们使用对应的变量。<br>    •    下个参数应该总是被设为0（历史遗留的问题）。<br>    •    第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。<br>    •    最后一个参数是真正的图像数据。<br>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</p><p>生成一个纹理的过程应该看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unsigned int texture;</span><br><span class="line">glGenTextures(1, &amp;texture);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, texture);</span><br><span class="line">// 为当前绑定的纹理对象设置环绕、过滤方式</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   </span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line">// 加载并生成纹理</span><br><span class="line">int width, height, nrChannels;</span><br><span class="line">unsigned char *data = loadImage(&apos;imagename&apos;);</span><br><span class="line">if (data)</span><br><span class="line">&#123;</span><br><span class="line">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line">    glGenerateMipmap(GL_TEXTURE_2D);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Failed to load texture&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;纹理&quot;&gt;&lt;a href=&quot;#纹理&quot; class=&quot;headerlink&quot; title=&quot;纹理&quot;&gt;&lt;/a&gt;纹理&lt;/h1&gt;&lt;p&gt;我们已经了解到，我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOS-OPENGLES1</title>
    <link href="http://yoursite.com/2018/06/19/IOS-OPENGLES1/"/>
    <id>http://yoursite.com/2018/06/19/IOS-OPENGLES1/</id>
    <published>2018-06-19T05:48:37.000Z</published>
    <updated>2018-06-19T05:48:37.829Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO KVC -详解</title>
    <link href="http://yoursite.com/2018/06/13/KVO-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/13/KVO-详解/</id>
    <published>2018-06-13T01:25:14.000Z</published>
    <updated>2018-06-13T01:39:35.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="KVO内部实现原理"><a href="#KVO内部实现原理" class="headerlink" title="KVO内部实现原理"></a>KVO内部实现原理</h2><p>KVO是基于runtime机制实现的</p><p>当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter 方法。派生类在被重写的setter方法内实现真正的通知机制<br>如果原类为Person，那么生成的派生类名为NSKVONotifying_Person</p><p>每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法</p><p>键值观察通知依赖于NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey:；在一个被观察属性发生改变之前， willChangeValueForKey:一定会被调用，这就 会记录旧的值<br>而当改变发生后，didChangeValueForKey:会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</p><p>补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p><p>(!img)[]</p><h2 id="KVC底层实现原理"><a href="#KVC底层实现原理" class="headerlink" title="KVC底层实现原理"></a>KVC底层实现原理</h2><p>KVC运用了一个isa-swizzling技术. isa-swizzling就是类型混合指针机制, 将2个对象的isa指针互相调换, 就是俗称的黑魔法<br>KVC主要通过isa-swizzling, 来实现其内部查找定位的. 默认的实现方法由NSOject提供isa指针, 如其名称所指,(就是is a kind of的意思), 指向分发表对象的类. 该分发表实际上包含了指向实现类中的方法的指针, 和其它数据。</p><p>具体主要分为三大步<br>1.寻找该属性有没有setsetter方法？有，就直接赋值<br>2.寻找有没有该属性带下划线的成员属性？有，就直接赋值<br>3.寻找有没有该属性的成员属性？有，就直接赋值</p><p>或者这么说<br>1.首先搜索setKey:方法.(key指成员变量名, 首字母大写)<br>2.上面的setter方法没找到, 如果类方法accessInstanceVariablesDirectly返回YES. 那么按 _key, _isKey，key, iskey的顺序搜索成员名.(NSKeyValueCodingCatogery中实现的类方法, 默认实现为返回YES)<br>3.如果没有找到成员变量, 调用setValue:forUnderfinedKey:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[object setValue:@&quot;13123&quot; forKey:@&quot;uuid&quot;];</span><br><span class="line">就会被编译器处理成:</span><br><span class="line">// 首先找到对应sel</span><br><span class="line">SEL sel = sel_get_ uuid(&quot;setValue:forKey:&quot;);</span><br><span class="line">// 根据object-&gt;isa找到sel对应的IMP实现指针</span><br><span class="line">IMP method = objc_msg_lookup (object-&gt;isa,sel);</span><br><span class="line">// 调用指针完成KVC赋值</span><br><span class="line">method(object, sel, @&quot;13123&quot;, @&quot;uuid&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;KVO内部实现原理&quot;&gt;&lt;a href=&quot;#KVO内部实现原理&quot; class=&quot;headerlink&quot; title=&quot;KVO内部实现原理&quot;&gt;&lt;/a&gt;KVO内部实现原理&lt;/h2&gt;&lt;p&gt;KVO是基于runtime机制实现的&lt;/p&gt;
&lt;p&gt;当某个类的属性对象第一次被观察时
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>__block 实现原理</title>
    <link href="http://yoursite.com/2018/06/13/%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/13/关键字的底层实现原理/</id>
    <published>2018-06-13T01:25:14.000Z</published>
    <updated>2018-06-13T03:13:36.062Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在block内如何修改block外部变量？</span><br></pre></td></tr></table></figure><p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 0;</span><br><span class="line">void (^foo)(void) = ^&#123; </span><br><span class="line">       a = 1; </span><br><span class="line"> &#125;;</span><br><span class="line">foo(); </span><br><span class="line">//这里，a的值被修改为1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们都知道：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。</span><br></pre></td></tr></table></figure><p>Block不允许修改外部变量的值Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__block int a = 0;</span><br><span class="line">NSLog(@&quot;定义前：%p&quot;, &amp;a);         //栈区</span><br><span class="line"> void (^foo)(void) = ^&#123;</span><br><span class="line">       a = 1;</span><br><span class="line">       NSLog(@&quot;block内部：%p&quot;, &amp;a);    //堆区</span><br><span class="line">   &#125;;</span><br><span class="line">NSLog(@&quot;定义后：%p&quot;, &amp;a);         //堆区</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8</span><br><span class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8</span><br><span class="line">2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8</span><br></pre></td></tr></table></figure><p>定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址</p><p>那么如何证明“block内部”打印的是堆地址？<br>把三个16进制的内存地址转成10进制就是<br>    1    定义后前：6171559672<br>    2    block内部：5732708296<br>    3    定义后后：5732708296<br>中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了<br>这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。</p><p>block本身是像对象一样可以retain，和release。但是，block在创建的时候，它的内存是分配在栈(stack)上，而不是在堆(heap)上。他本身的作于域是属于创建时候的作用域，一旦在创建时候的作用域外面调用block将导致程序崩溃。使用retain也可以，但是block的retain行为默认是用copy的行为实现的，<br>因为block变量默认是声明为栈变量的，为了能够在block的声明域外使用，所以要把block拷贝（copy）到堆，所以说为了block属性声明和实际的操作一致，最好声明为copy。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>FFMPEG-函数详解</title>
    <link href="http://yoursite.com/2018/06/03/FFMPEG-%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/03/FFMPEG-函数详解/</id>
    <published>2018-06-03T01:14:11.000Z</published>
    <updated>2018-06-09T04:18:15.553Z</updated>
    
    <content type="html"><![CDATA[<p>#FFMPEG 函数</p><h2 id="swr-convert"><a href="#swr-convert" class="headerlink" title="swr_convert"></a>swr_convert</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解码得到的数据类型为float 4bit，而播放器播放的格式一般为S16（signed 16bit）,就需要对解码得到的数据进行转换</span><br></pre></td></tr></table></figure><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int swr_convert(struct SwrContext * s, uint8_t ** out,   int out_count, const uint8_t ** in,  int in_count )</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>s</td><td>allocated Swr context, with parameters set</td></tr><tr><td>out</td><td>output buffers, only the first one need be set in case of packed audio</td></tr><tr><td>out_count</td><td>amount of space available for output in samples per channel</td></tr><tr><td>in</td><td>input buffers, only the first one need to be set in case of packed audio</td></tr><tr><td>in_count</td><td>number of input samples available in one channel</td></tr></tbody></table><h2 id="av-samples-get-buffer-size"><a href="#av-samples-get-buffer-size" class="headerlink" title="av_samples_get_buffer_size"></a>av_samples_get_buffer_size</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int av_samples_get_buffer_size(int *linesize, int nb_channels, int nb_samples,  </span><br><span class="line">enum AVSampleFormat sample_fmt, int alig)</span><br></pre></td></tr></table></figure><p>音频一般是采用成PCM格式，而计算PCM格式音频尺寸，就需要如下几个参数。</p><p>通道数，采样频率，采用格式。</p><p>通道数：个人理解，就是同时有个几个设备在进行音频的采样，最少为1，一般通道数越多，音质越好。<br>采样频率：（也称为采样速度或者采样频率）定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。<br>采用位数：既然采样频率表示每秒采样的个数，那么如何描述每个采样点呢？用什么方法独立每个采样点值的区别呢？也就是如何度量每个采样点，而这正是采样格式出现的意义。通常使用16bit，也就是2的16次方，共有65536个不同的度量值，这样采样位数越高，音频度量化的就越精细，音质同样也就越高。</p><p>所以音频所占用字节数 = 通道数 <em> 采用频率(Hz) </em> 采用位数(byte)</p><p>而在ffmpeg里面就使用av_sample_get_buffer_size来计算音频占用的字节数。</p><h2 id="av-frame-get-best-effort-timestamp"><a href="#av-frame-get-best-effort-timestamp" class="headerlink" title="av_frame_get_best_effort_timestamp"></a>av_frame_get_best_effort_timestamp</h2><p>获得音频的位置</p><h2 id="av-frame-get-pkt-duration"><a href="#av-frame-get-pkt-duration" class="headerlink" title="av_frame_get_pkt_duration"></a>av_frame_get_pkt_duration</h2><p>获得音频数据播放的时长</p><h1 id="SwrContext"><a href="#SwrContext" class="headerlink" title="SwrContext"></a>SwrContext</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重采样</span><br></pre></td></tr></table></figure><p>重采样，也就是对已得到的数据进行重新的采样；比如，原先的PCM音频数据是2 个声道，44100采样率，32bit 单精度型(sample format采样格式)。那么通过重采样，我们改变它的声道数、采样率和采样格式。</p><h2 id="AVSampleFormat"><a href="#AVSampleFormat" class="headerlink" title="AVSampleFormat"></a>AVSampleFormat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">enum AVSampleFormat &#123;  </span><br><span class="line">  AV_SAMPLE_FMT_NONE = -1,  </span><br><span class="line">AV_SAMPLE_FMT_U8, ///&lt; unsigned 8 bits  </span><br><span class="line">AV_SAMPLE_FMT_S16,///&lt; signed 16 bits  </span><br><span class="line">AV_SAMPLE_FMT_S32,///&lt; signed 32 bits  </span><br><span class="line">AV_SAMPLE_FMT_FLT, ///&lt; float  </span><br><span class="line">AV_SAMPLE_FMT_DBL, ///&lt; double  </span><br><span class="line">AV_SAMPLE_FMT_U8P, ///&lt; unsigned 8 bits, planar  </span><br><span class="line">AV_SAMPLE_FMT_S16P,  ///&lt; signed 16 bits, planar  </span><br><span class="line">AV_SAMPLE_FMT_S32P, ///&lt; signed 32 bits, planar  </span><br><span class="line">AV_SAMPLE_FMT_FLTP,  ///&lt; float, planar  </span><br><span class="line">AV_SAMPLE_FMT_DBLP, ///&lt; double, planar  </span><br><span class="line">AV_SAMPLE_FMT_S64, ///&lt; signed 64 bits  </span><br><span class="line">AV_SAMPLE_FMT_S64P, ///&lt; signed 64 bits, planar </span><br><span class="line">AV_SAMPLE_FMT_NB //&lt; Number of sample formats. DO NOT USE if linking dynamically  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>vDSP_vflt16将非交错的16位带符号整数（non-interleaved 16-bit signed integers）转换成单精度浮点数。为什么是16位带符号整数？原因是，这取决于<br>AudioStreamBasicDescription.mBitsPerChannel字段的值。当AudioStreamBasicDescription.mBitsPerChannel为16时，则调用vDSP_vflt16。<br>当AudioStreamBasicDescription.mBitsPerChannel为32时，则调用vDSP_vflt32。</p><p>vDSP_vsmul()对数据做了一个乘法的运算</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#FFMPEG 函数&lt;/p&gt;
&lt;h2 id=&quot;swr-convert&quot;&gt;&lt;a href=&quot;#swr-convert&quot; class=&quot;headerlink&quot; title=&quot;swr_convert&quot;&gt;&lt;/a&gt;swr_convert&lt;/h2&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OPENGLES-基础篇</title>
    <link href="http://yoursite.com/2018/05/31/OPENGLES-%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
    <id>http://yoursite.com/2018/05/31/OPENGLES-基础篇/</id>
    <published>2018-05-31T07:27:05.000Z</published>
    <updated>2018-07-03T07:33:44.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三角形的绘制"><a href="#三角形的绘制" class="headerlink" title="三角形的绘制"></a>三角形的绘制</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="顶点数组对象"><a href="#顶点数组对象" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h3><p>Vertex Array Object，VAO</p><h3 id="顶点缓冲对象"><a href="#顶点缓冲对象" class="headerlink" title="顶点缓冲对象"></a>顶点缓冲对象</h3><p>Vertex Buffer Object，VBO</p><h3 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h3><p>Element Buffer Object，EBO或Index Buffer Object，IBO</p><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。我们会简单地讨论一下图形渲染管线，以及如何利用它创建一些漂亮的像素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。</span><br></pre></td></tr></table></figure><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>图形渲染管线接受一组3D坐标，然后把它们转变为你屏幕上的有色2D像素输出。图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p><p>有些着色器允许开发者自己配置，这就允许我们用自己写的着色器来替换默认的。这样我们就可以更细致地控制图形渲染管线中的特定部分了，而且因为它们运行在GPU上，所以它们可以给我们节约宝贵的CPU时间，OpenGL着色器是用OpenGL着色器语言(OpenGL Shading Language, GLSL)写成的，在下一节中我们再花更多时间研究它</p><p>下面，你会看到一个图形渲染管线的每个阶段的抽象展示。要注意蓝色部分代表的是我们可以注入自定义的着色器的部分<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/vertex_shader.png?raw=true" alt=""><br>如你所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段。我们会概括性地解释一下渲染管线的每个部分，让你对图形渲染管线的工作方式有个大概了解。<br>首先，我们以数组的形式传递3个3D坐标作为图形渲染管线的输入，用来表示一个三角形，这个数组叫做顶点数据(Vertex Data)；顶点数据是一系列顶点的集合。一个顶点(Vertex)是一个3D坐标的数据的集合。而顶点数据是用顶点属性(Vertex Attribute)表示的，它可以包含任何我们想用的数据，但是简单起见，我们还是假定每个顶点只由一个3D位置(译注1)和一些颜色值组成的吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们谈论一个“位置”的时候，它代表在一个“空间”中所处地点的这个特殊属性；同时“空间”代表着任何一种坐标系，比如x、y、z三维坐标系，x、y二维坐标系，或者一条直线上的x和y的线性关系，只不过二维坐标系是一个扁扁的平面空间，而一条直线是一个很瘦的长长的空间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了让OpenGL知道我们的坐标和颜色值构成的到底是什么，OpenGL需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元(Primitive)，任何一个绘制指令的调用都将把图元传递给OpenGL。这是其中的几个：GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP。</span><br></pre></td></tr></table></figure><p>图形渲染管线的第一个部分是顶点着色器(Vertex Shader)，它把一个单独的顶点作为输入。顶点着色器主要的目的是把3D坐标转为另一种3D坐标（后面会解释），同时顶点着色器允许我们对顶点属性进行一些基本处理。<br>图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；本节例子中是一个三角形。<br>图元装配阶段的输出会传递给几何着色器(Geometry Shader)。几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状。例子中，它生成了另一个三角形。<br>几何着色器的输出会被传入光栅化阶段(Rasterization Stage)，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenGL中的一个片段是OpenGL渲染一个像素所需的所有数据。</span><br></pre></td></tr></table></figure><p>片段着色器的主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。</p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做Alpha测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值（后面会讲），用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。<br>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。然而，对于大多数场合，我们只需要配置顶点和片段着色器就行了。几何着色器是可选的，通常使用它默认的着色器就行了。<br>在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。出于这个原因，刚开始学习现代OpenGL的时候可能会非常困难，因为在你能够渲染自己的第一个三角形之前已经需要了解一大堆知识了。在本节结束你最终渲染出你的三角形的时候，你也会了解到非常多的图形编程知识。</p><h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）<br>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">    -0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.5f, -0.5f, 0.0f,</span><br><span class="line">     0.0f,  0.5f, 0.0f</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度(Depth，译注2)都是一样的，从而使它看上去像是2D的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常深度可以理解为z坐标，它代表一个像素在空间中和你的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</span><br></pre></td></tr></table></figure><p>标准化设备坐标(Normalized Device Coordinates, NDC)<br>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gles-1.png?raw=ture" alt=""></p><p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。<br>你的标准化设备坐标接着会变换为屏幕空间坐标(Screen-space Coordinates)，这是使用你通过glViewport函数提供的数据，进行视口变换(Viewport Transform)完成的。所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。<br>我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。<br>顶点缓冲对象是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VBO;</span><br><span class="line">glGenBuffers(1, &amp;VBO);</span><br></pre></td></tr></table></figure><p>OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br></pre></td></tr></table></figure></p><p>从这一刻起，我们使用的任何（在GL_ARRAY_BUFFER目标上的）缓冲调用都会用来配置当前绑定的缓冲(VBO)。然后我们可以调用glBufferData函数，它会把之前定义的顶点数据复制到缓冲的内存中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure></p><p>glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。</p><p>第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式：</p><pre><code>•    GL_STATIC_DRAW ：数据不会或几乎不会改变。•    GL_DYNAMIC_DRAW：数据会被改变很多。•    GL_STREAM_DRAW ：数据每次绘制时都会改变。</code></pre><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是GL_STATIC_DRAW。如果，比如说一个缓冲中的数据将频繁被改变，那么使用的类型就是GL_DYNAMIC_DRAW或GL_STREAM_DRAW，这样就能确保显卡把数据放在能够高速写入的内存部分。<br>现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。下面我们会创建一个顶点和片段着色器来真正处理这些数据。现在我们开始着手创建它们吧。</p><h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>顶点着色器(Vertex Shader)是几个可编程着色器中的一个。如果我们打算做渲染的话，现代OpenGL需要我们至少设置一个顶点和一个片段着色器。我们会简要介绍一下着色器以及配置两个非常简单的着色器来绘制我们第一个三角形.</p><p>我们需要做的第一件事是用着色器语言GLSL(OpenGL Shading Language)编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。下面你会看到一个非常基础的GLSL顶点着色器的源代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h2><p>我们已经写了一个顶点着色器源码（储存在一个C的字符串中），但是为了能够让OpenGL使用它，我们必须在运行时动态编译它的源码。<br>我们首先要做的是创建一个着色器对象，注意还是用ID来引用的。所以我们储存这个顶点着色器为unsigned int，然后用glCreateShader创建这个着色器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>我们把需要创建的着色器类型以参数形式提供给glCreateShader。由于我们正在创建一个顶点着色器，传递的参数是GL_VERTEX_SHADER。</p><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(vertexShader, 1, &amp;vertexShaderSource, NULL);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p>glShaderSource函数把要编译的着色器对象作为第一个参数。第二参数指定了传递的源码字符串数量，这里只有一个。第三个参数是顶点着色器真正的源码，第四个参数我们先设置为NULL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">你可能会希望检测在调用glCompileShader后编译是否成功了，如果没成功的话，你还会希望知道错误是什么，这样你才能修复它们。检测编译时错误可以通过以下代码来实现：</span><br><span class="line">int  success;</span><br><span class="line">char infoLog[512];</span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">首先我们定义一个整型变量来表示是否成功编译，还定义了一个储存错误消息（如果有的话）的容器。然后我们用glGetShaderiv检查是否编译成功。如果编译失败，我们会用glGetShaderInfoLog获取错误消息，然后打印它。</span><br><span class="line">if(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);</span><br><span class="line">    std::cout &lt;&lt; &quot;ERROR::SHADER::VERTEX::COMPILATION_FAILED\n&quot; &lt;&lt; infoLog &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##片段着色器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编译片段着色器的过程与顶点着色器类似，只不过我们使用GL_FRAGMENT_SHADER常量作为着色器类型：</span><br><span class="line">unsigned int fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><h2 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h2><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本。如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。<br>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。<br>创建一个程序对象很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure></p><p>glCreateProgram函数创建一个程序，并返回新创建程序对象的ID引用。现在我们需要把之前编译的着色器附加到程序对象上，然后用glLinkProgram链接它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用glLinkProgram链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志。与上面不同，我们不会调用glGetShaderiv和glGetShaderInfoLog，现在我们使用：</span><br><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">if(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果就是一个程序对象，我们可以调用glUseProgram函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：<br>glUseProgram(shaderProgram);</p><p>在glUseProgram函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器)了。<br>对了，在把着色器对象链接到程序对象以后，记得删除着色器对象，我们不再需要它们了：<br>glDeleteShader(vertexShader);<br>glDeleteShader(fragmentShader);<br>现在，我们已经把输入顶点数据发送给了GPU，并指示了GPU如何在顶点和片段着色器中处理它。就快要完成了，但还没结束，OpenGL还不知道它该如何解释内存中的顶点数据，以及它该如何将顶点数据链接到顶点着色器的属性上。我们需要告诉OpenGL怎么做。</p><h2 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h2><p>顶点着色器允许我们指定任何以顶点属性为形式的输入。这使其具有很强的灵活性的同时，它还的确意味着我们必须手动指定输入数据的哪一个部分对应顶点着色器的哪一个顶点属性。所以，我们必须在渲染前指定OpenGL该如何解释顶点数据。<br>我们的顶点缓冲数据会被解析为下面这样子：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/vertex_attribute_pointer.png?raw=true" alt=""></p><pre><code>•    位置数据被储存为32位（4字节）浮点值。•    每个位置包含3个这样的值。•    在这3个值之间没有空隙（或其他值）。这几个值在数组中紧密排列(Tightly Packed)。•    数据中第一个值在缓冲开始的位置。</code></pre><p>有了这些信息我们就可以使用glVertexAttribPointer函数告诉OpenGL该如何解析顶点数据（应用到逐个顶点属性上）了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br></pre></td></tr></table></figure><p>glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们：</p><pre><code>•    第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用layout(location = 0)定义了position顶点属性的位置值(Location)吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入0。•    第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。•    第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。•    下个参数定义我们是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。•    第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。•    最后一个参数的类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVetexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVetexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。</span><br></pre></td></tr></table></figure><p>现在我们已经定义了OpenGL该如何解释顶点数据，我们现在应该使用glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 0. 复制顶点数组到缓冲中供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">// 1. 设置顶点属性指针</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line">// 2. 当我们渲染一个物体时要使用着色器程序</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">// 3. 绘制物体</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><p>每当我们绘制一个物体的时候都必须重复这一过程。这看起来可能不多，但是如果有超过5个顶点属性，上百个不同物体呢（这其实并不罕见）。绑定正确的缓冲对象，为每个物体配置所有顶点属性很快就变成一件麻烦事。有没有一些方法可以使我们把所有这些状态配置储存在一个对象中，并且可以通过绑定这个对象来恢复状态呢？</p><h2 id="顶点数组对象-1"><a href="#顶点数组对象-1" class="headerlink" title="顶点数组对象"></a>顶点数组对象</h2><p>顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。</span><br></pre></td></tr></table></figure><p>一个顶点数组对象会储存以下这些内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">•glEnableVertexAttribArray和glDisableVertexAttribArray的调用。</span><br><span class="line">•通过glVertexAttribPointer设置的顶点属性配置。</span><br><span class="line">•通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。</span><br></pre></td></tr></table></figure><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/vertex_array_objects.png?raw=true" alt=""></p><p>创建一个VAO和创建一个VBO很类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int VAO;</span><br><span class="line">glGenVertexArrays(1, &amp;VAO);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span><br><span class="line">// 1. 绑定VAO</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">// 3. 设置顶点属性指针</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">// ..:: 绘制代码（渲染循环中） :: ..</span><br><span class="line">// 4. 绘制物体</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">someOpenGLFunctionThatDrawsOurTriangle();</span><br></pre></td></tr></table></figure><h2 id="索引缓冲对象-1"><a href="#索引缓冲对象-1" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h2><p>在渲染顶点这一话题上我们还有最有一个需要讨论的东西——索引缓冲对象(Element Buffer Object，EBO，也叫Index Buffer Object，IBO)。要解释索引缓冲对象的工作方式最好还是举个例子：假设我们不再绘制一个三角形而是绘制一个矩形。我们可以绘制两个三角形来组成一个矩形（OpenGL主要处理三角形）。这会生成下面的顶点的集合：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">    // 第一个三角形</span><br><span class="line">    0.5f, 0.5f, 0.0f,   // 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  // 右下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f,  // 左上角</span><br><span class="line">    // 第二个三角形</span><br><span class="line">    0.5f, -0.5f, 0.0f,  // 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, // 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   // 左上角</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了。我们指定了右下角和左上角两次！一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。当我们有包括上千个三角形的模型之后这个问题会更糟糕，这会产生一大堆浪费。更好的解决方案是只储存不同的顶点，并设定绘制这些顶点的顺序。这样子我们只要储存4个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。如果OpenGL提供这个功能就好了，对吧？<br>很幸运，索引缓冲对象的工作方式正是这样的。和顶点缓冲对象一样，EBO也是一个缓冲，它专门储存索引，OpenGL调用这些顶点的索引来决定该绘制哪个顶点。所谓的索引绘制(Indexed Drawing)正是我们问题的解决方案。首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float vertices[] = &#123;</span><br><span class="line">    0.5f, 0.5f, 0.0f,   // 右上角</span><br><span class="line">    0.5f, -0.5f, 0.0f,  // 右下角</span><br><span class="line">    -0.5f, -0.5f, 0.0f, // 左下角</span><br><span class="line">    -0.5f, 0.5f, 0.0f   // 左上角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">unsigned int indices[] = &#123; // 注意索引从0开始! </span><br><span class="line">    0, 1, 3, // 第一个三角形</span><br><span class="line">    1, 2, 3  // 第二个三角形</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了4个顶点，而不是6个。下一步我们需要创建索引缓冲对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned int EBO;</span><br><span class="line">glGenBuffers(1, &amp;EBO);</span><br></pre></td></tr></table></figure><p>与VBO类似，我们先绑定EBO然后用glBufferData把索引复制到缓冲里。同样，和VBO类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为GL_ELEMENT_ARRAY_BUFFER。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了GL_ELEMENT_ARRAY_BUFFER当作缓冲目标。最后一件要做的事是用glDrawElements来替换glDrawArrays函数，来指明我们从索引缓冲渲染。使用glDrawElements时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span><br></pre></td></tr></table></figure><p>第一个参数指定了我们绘制的模式，这个和glDrawArrays的一样。第二个参数是我们打算绘制顶点的个数，这里填6，也就是说我们一共需要绘制6个顶点。第三个参数是索引的类型，这里是GL_UNSIGNED_INT。最后一个参数里我们可以指定EBO中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写0。<br>glDrawElements函数从当前绑定到GL_ELEMENT_ARRAY_BUFFER目标的EBO中获取索引。这意味着我们必须在每次要用索引渲染一个物体时绑定相应的EBO，这还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态。VAO绑定时正在绑定的索引缓冲对象会被保存为VAO的元素缓冲对象。绑定VAO的同时也会自动绑定EBO。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/vertex_array_objects_ebo.png?raw=true" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当目标是GL_ELEMENT_ARRAY_BUFFER的时候，VAO会储存glBindBuffer的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ..:: 初始化代码 :: ..</span><br><span class="line">// 1. 绑定顶点数组对象</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">// 4. 设定顶点属性指针</span><br><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span><br><span class="line">glEnableVertexAttribArray(0);</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">// ..:: 绘制代码（渲染循环中） :: ..</span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)</span><br><span class="line">glBindVertexArray(0);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线框模式(Wireframe Mode)</span><br><span class="line">要想用线框模式绘制你的三角形，你可以通过glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)函数配置OpenGL如何绘制图元。第一个参数表示我们打算将其应用到所有的三角形的正面和背面，第二个参数告诉我们用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)将其设置回默认模式。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;三角形的绘制&quot;&gt;&lt;a href=&quot;#三角形的绘制&quot; class=&quot;headerlink&quot; title=&quot;三角形的绘制&quot;&gt;&lt;/a&gt;三角形的绘制&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>YUV详解</title>
    <link href="http://yoursite.com/2018/05/31/YUV%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/31/YUV详解/</id>
    <published>2018-05-31T03:22:03.000Z</published>
    <updated>2018-05-31T03:22:03.236Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FFMPEG-1</title>
    <link href="http://yoursite.com/2018/05/31/FFMPEG-1/"/>
    <id>http://yoursite.com/2018/05/31/FFMPEG-1/</id>
    <published>2018-05-31T01:41:24.000Z</published>
    <updated>2018-05-31T01:41:24.993Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2018/05/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/05/20/数据结构/</id>
    <published>2018-05-20T15:06:21.000Z</published>
    <updated>2018-05-20T15:06:21.512Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++拷贝函数</title>
    <link href="http://yoursite.com/2018/05/20/C-%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/05/20/C-拷贝函数/</id>
    <published>2018-05-20T15:06:08.000Z</published>
    <updated>2018-05-20T15:06:08.667Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++虚函数</title>
    <link href="http://yoursite.com/2018/05/20/C-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/05/20/C-虚函数/</id>
    <published>2018-05-20T15:05:53.000Z</published>
    <updated>2018-05-20T15:05:53.299Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>React-native</title>
    <link href="http://yoursite.com/2018/05/16/React-native/"/>
    <id>http://yoursite.com/2018/05/16/React-native/</id>
    <published>2018-05-16T08:40:15.000Z</published>
    <updated>2018-05-16T08:59:31.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Native-简单的使用"><a href="#React-Native-简单的使用" class="headerlink" title="React-Native 简单的使用"></a>React-Native 简单的使用</h1><h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h2 id="宽度"><a href="#宽度" class="headerlink" title="宽度"></a>宽度</h2><h2 id="高度"><a href="#高度" class="headerlink" title="高度"></a>高度</h2><h2 id="使用FlexBox布局"><a href="#使用FlexBox布局" class="headerlink" title="使用FlexBox布局"></a>使用FlexBox布局</h2><h2 id="处理文本输入"><a href="#处理文本输入" class="headerlink" title="处理文本输入"></a>处理文本输入</h2><h2 id="滚动视图"><a href="#滚动视图" class="headerlink" title="滚动视图"></a>滚动视图</h2><h2 id="使用长列表"><a href="#使用长列表" class="headerlink" title="使用长列表"></a>使用长列表</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h2 id="其他参考资源"><a href="#其他参考资源" class="headerlink" title="其他参考资源"></a>其他参考资源</h2><h1 id="进阶指南"><a href="#进阶指南" class="headerlink" title="进阶指南"></a>进阶指南</h1><h2 id="集成到现有的原生应用"><a href="#集成到现有的原生应用" class="headerlink" title="集成到现有的原生应用"></a>集成到现有的原生应用</h2><h2 id="使用导航器跳转页面"><a href="#使用导航器跳转页面" class="headerlink" title="使用导航器跳转页面"></a>使用导航器跳转页面</h2><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h2 id="处理触摸事件"><a href="#处理触摸事件" class="headerlink" title="处理触摸事件"></a>处理触摸事件</h2><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h2 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h2><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h2 id="直接操作"><a href="#直接操作" class="headerlink" title="直接操作"></a>直接操作</h2><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><h2 id="JavaScript环境"><a href="#JavaScript环境" class="headerlink" title="JavaScript环境"></a>JavaScript环境</h2><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><h2 id="特定平台代码"><a href="#特定平台代码" class="headerlink" title="特定平台代码"></a>特定平台代码</h2><h2 id="手势响应系统"><a href="#手势响应系统" class="headerlink" title="手势响应系统"></a>手势响应系统</h2><h1 id="社区资源"><a href="#社区资源" class="headerlink" title="社区资源"></a>社区资源</h1><h2 id="js-coach第三方组件库"><a href="#js-coach第三方组件库" class="headerlink" title="js.coach第三方组件库"></a>js.coach第三方组件库</h2><h2 id="中文论坛组件分享区"><a href="#中文论坛组件分享区" class="headerlink" title="中文论坛组件分享区"></a>中文论坛组件分享区</h2><h2 id="中文论坛问题求助区"><a href="#中文论坛问题求助区" class="headerlink" title="中文论坛问题求助区"></a>中文论坛问题求助区</h2><h1 id="使用指南-IOS"><a href="#使用指南-IOS" class="headerlink" title="使用指南(IOS)"></a>使用指南(IOS)</h1><h2 id="原生模块"><a href="#原生模块" class="headerlink" title="原生模块"></a>原生模块</h2><h2 id="原生UI组件"><a href="#原生UI组件" class="headerlink" title="原生UI组件"></a>原生UI组件</h2><h2 id="链接原生库"><a href="#链接原生库" class="headerlink" title="链接原生库"></a>链接原生库</h2><h2 id="在设备上运行"><a href="#在设备上运行" class="headerlink" title="在设备上运行"></a>在设备上运行</h2><h2 id="在模拟器上运行"><a href="#在模拟器上运行" class="headerlink" title="在模拟器上运行"></a>在模拟器上运行</h2><h2 id="和原生端通信"><a href="#和原生端通信" class="headerlink" title="和原生端通信"></a>和原生端通信</h2><h2 id="iOS应用扩展"><a href="#iOS应用扩展" class="headerlink" title="iOS应用扩展"></a>iOS应用扩展</h2><h1 id="使用指南-Android"><a href="#使用指南-Android" class="headerlink" title="使用指南(Android)"></a>使用指南(Android)</h1><h2 id="原生模块-1"><a href="#原生模块-1" class="headerlink" title="原生模块"></a>原生模块</h2><h2 id="原生UI组件-1"><a href="#原生UI组件-1" class="headerlink" title="原生UI组件"></a>原生UI组件</h2><h2 id="Headless-JS（后台任务）"><a href="#Headless-JS（后台任务）" class="headerlink" title="Headless JS（后台任务）"></a>Headless JS（后台任务）</h2><p>##在设备上运行</p><p>##打包APK</p><p>##调试Android UI性能</p><p>##从源代码编译React Native</p><p>##和原生端通信</p><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="AccessibilityInfo"><a href="#AccessibilityInfo" class="headerlink" title="AccessibilityInfo"></a>AccessibilityInfo</h2><h2 id="ActivityIndicator"><a href="#ActivityIndicator" class="headerlink" title="ActivityIndicator"></a>ActivityIndicator</h2><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><h2 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h2><h2 id="DatePickerIOS"><a href="#DatePickerIOS" class="headerlink" title="DatePickerIOS"></a>DatePickerIOS</h2><h2 id="DrawerLayoutAndroid"><a href="#DrawerLayoutAndroid" class="headerlink" title="DrawerLayoutAndroid"></a>DrawerLayoutAndroid</h2><h2 id="FlatList"><a href="#FlatList" class="headerlink" title="FlatList"></a>FlatList</h2><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2><h2 id="KeyboardAvoidingView"><a href="#KeyboardAvoidingView" class="headerlink" title="KeyboardAvoidingView"></a>KeyboardAvoidingView</h2><h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h2 id="ListView-DataSource"><a href="#ListView-DataSource" class="headerlink" title="ListView.DataSource"></a>ListView.DataSource</h2><h2 id="MaskedViewIOS"><a href="#MaskedViewIOS" class="headerlink" title="MaskedViewIOS"></a>MaskedViewIOS</h2><h2 id="Modal"><a href="#Modal" class="headerlink" title="Modal"></a>Modal</h2><h2 id="NavigatorIOS"><a href="#NavigatorIOS" class="headerlink" title="NavigatorIOS"></a>NavigatorIOS</h2><h2 id="Picker"><a href="#Picker" class="headerlink" title="Picker"></a>Picker</h2><h2 id="PickerIOS"><a href="#PickerIOS" class="headerlink" title="PickerIOS"></a>PickerIOS</h2><h2 id="ProgressBarAndroid"><a href="#ProgressBarAndroid" class="headerlink" title="ProgressBarAndroid"></a>ProgressBarAndroid</h2><h2 id="ProgressViewIOS"><a href="#ProgressViewIOS" class="headerlink" title="ProgressViewIOS"></a>ProgressViewIOS</h2><h2 id="TabBarIOS-Item"><a href="#TabBarIOS-Item" class="headerlink" title="TabBarIOS.Item"></a>TabBarIOS.Item</h2><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><h2 id="TextInput"><a href="#TextInput" class="headerlink" title="TextInput"></a>TextInput</h2><h2 id="ToolbarAndroid"><a href="#ToolbarAndroid" class="headerlink" title="ToolbarAndroid"></a>ToolbarAndroid</h2><h2 id="TouchableHighlight"><a href="#TouchableHighlight" class="headerlink" title="TouchableHighlight"></a>TouchableHighlight</h2><h2 id="TouchableNativeFeedback"><a href="#TouchableNativeFeedback" class="headerlink" title="TouchableNativeFeedback"></a>TouchableNativeFeedback</h2><h2 id="TouchableOpacity"><a href="#TouchableOpacity" class="headerlink" title="TouchableOpacity"></a>TouchableOpacity</h2><h2 id="TouchableWithoutFeedback"><a href="#TouchableWithoutFeedback" class="headerlink" title="TouchableWithoutFeedback"></a>TouchableWithoutFeedback</h2><h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h2 id="ViewPagerAndroid"><a href="#ViewPagerAndroid" class="headerlink" title="ViewPagerAndroid"></a>ViewPagerAndroid</h2><h2 id="VirtualizedList"><a href="#VirtualizedList" class="headerlink" title="VirtualizedList"></a>VirtualizedList</h2><h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="ActionSheetIOS"><a href="#ActionSheetIOS" class="headerlink" title="ActionSheetIOS"></a>ActionSheetIOS</h2><h2 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h2><h2 id="AlertIOS"><a href="#AlertIOS" class="headerlink" title="AlertIOS"></a>AlertIOS</h2><h2 id="Animated"><a href="#Animated" class="headerlink" title="Animated"></a>Animated</h2><h2 id="AppRegistry"><a href="#AppRegistry" class="headerlink" title="AppRegistry"></a>AppRegistry</h2><h2 id="AppState"><a href="#AppState" class="headerlink" title="AppState"></a>AppState</h2><h2 id="AsyncStorage"><a href="#AsyncStorage" class="headerlink" title="AsyncStorage"></a>AsyncStorage</h2><h2 id="BackAndroid"><a href="#BackAndroid" class="headerlink" title="BackAndroid"></a>BackAndroid</h2><h2 id="BackHandler"><a href="#BackHandler" class="headerlink" title="BackHandler"></a>BackHandler</h2><h2 id="CameraRoll"><a href="#CameraRoll" class="headerlink" title="CameraRoll"></a>CameraRoll</h2><h2 id="Clipboard"><a href="#Clipboard" class="headerlink" title="Clipboard"></a>Clipboard</h2><h2 id="DatePickerAndroid"><a href="#DatePickerAndroid" class="headerlink" title="DatePickerAndroid"></a>DatePickerAndroid</h2><h2 id="Dimensions"><a href="#Dimensions" class="headerlink" title="Dimensions"></a>Dimensions</h2><h2 id="Easing"><a href="#Easing" class="headerlink" title="Easing"></a>Easing</h2><h2 id="Geolocation"><a href="#Geolocation" class="headerlink" title="Geolocation"></a>Geolocation</h2><h2 id="ImageEditor"><a href="#ImageEditor" class="headerlink" title="ImageEditor"></a>ImageEditor</h2><h2 id="ImagePickerIOS"><a href="#ImagePickerIOS" class="headerlink" title="ImagePickerIOS"></a>ImagePickerIOS</h2><h2 id="ImageStore"><a href="#ImageStore" class="headerlink" title="ImageStore"></a>ImageStore</h2><h2 id="InteractionManager"><a href="#InteractionManager" class="headerlink" title="InteractionManager"></a>InteractionManager</h2><h2 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h2><h2 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a>LayoutAnimation</h2><h2 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h2><h2 id="NativeMethodsMixin"><a href="#NativeMethodsMixin" class="headerlink" title="NativeMethodsMixin"></a>NativeMethodsMixin</h2><h2 id="NetInfo"><a href="#NetInfo" class="headerlink" title="NetInfo"></a>NetInfo</h2><h2 id="PanResponder"><a href="#PanResponder" class="headerlink" title="PanResponder"></a>PanResponder</h2><h2 id="PermissionsAndroid"><a href="#PermissionsAndroid" class="headerlink" title="PermissionsAndroid"></a>PermissionsAndroid</h2><h2 id="PixelRatio"><a href="#PixelRatio" class="headerlink" title="PixelRatio"></a>PixelRatio</h2><h2 id="PushNotificationIOS"><a href="#PushNotificationIOS" class="headerlink" title="PushNotificationIOS"></a>PushNotificationIOS</h2><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><h2 id="StyleSheet"><a href="#StyleSheet" class="headerlink" title="StyleSheet"></a>StyleSheet</h2><h2 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h2><h2 id="TimePickerAndroid"><a href="#TimePickerAndroid" class="headerlink" title="TimePickerAndroid"></a>TimePickerAndroid</h2><h2 id="ToastAndroid"><a href="#ToastAndroid" class="headerlink" title="ToastAndroid"></a>ToastAndroid</h2><h2 id="Vibration"><a href="#Vibration" class="headerlink" title="Vibration"></a>Vibration</h2><h1 id="布局样式属性"><a href="#布局样式属性" class="headerlink" title="布局样式属性"></a>布局样式属性</h1><h1 id="阴影样式属性"><a href="#阴影样式属性" class="headerlink" title="阴影样式属性"></a>阴影样式属性</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;React-Native-简单的使用&quot;&gt;&lt;a href=&quot;#React-Native-简单的使用&quot; class=&quot;headerlink&quot; title=&quot;React-Native 简单的使用&quot;&gt;&lt;/a&gt;React-Native 简单的使用&lt;/h1&gt;&lt;h2 id=&quot;p
      
    
    </summary>
    
      <category term="react-native" scheme="http://yoursite.com/categories/react-native/"/>
    
    
  </entry>
  
  <entry>
    <title>弹性盒子模型</title>
    <link href="http://yoursite.com/2018/05/15/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/05/15/弹性盒子模型/</id>
    <published>2018-05-15T07:48:54.000Z</published>
    <updated>2018-05-15T08:45:06.013Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/xiaohuochai/p/5323146.html#anchor4-1" target="_blank" rel="noopener">flex盒子模型</a>;</p><h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><ul><li>display: flex; 将对象作为弹性伸缩盒展示，用于块级元素</li><li>display: inline-flex; 将对象作为弹性伸缩盒展示，用于行内元素</li></ul><h2 id="注意兼容问题："><a href="#注意兼容问题：" class="headerlink" title="注意兼容问题："></a>注意兼容问题：</h2><ul><li>webkit内核浏览器应使用前缀-webkit</li><li>IE浏览器，可以很好的兼容IE11+版本，对于IE10只有部分可以兼容，且使用时需增加-ms，IE10浏览器中容器定义成弹性伸缩盒时，需使用display: -ms-flexbox</li></ul><p>示例的dom结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt; &lt;!--容器--&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt; &lt;!--子项--&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>示例的基础样式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 200px;</span><br><span class="line">  background-color: #58a;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">  width: 50px;</span><br><span class="line">  height: 50px;</span><br><span class="line">  margin: 2px;</span><br><span class="line">  background-color: #fb3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Flex-作用于Box容器上的6个属性介绍"><a href="#Flex-作用于Box容器上的6个属性介绍" class="headerlink" title="Flex 作用于Box容器上的6个属性介绍"></a>Flex 作用于Box容器上的6个属性介绍</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>用于指定Flex主轴的方向，继而决定 Flex子项在Flex容器中的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取值：row | row-reverse | column | column-reverse</span><br></pre></td></tr></table></figure><ul><li>row：默认值，表示水平方向从左到右排列，此时水平方向轴线为主轴</li><li>row-reverse：与row相反</li><li>column：表示垂直方向从上到下排列，此时垂直方向轴线为主轴</li><li>column-reverse：与column相反</li></ul><p>flex-direction四种取值的效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex_dirction1.png?raw=true" alt=""><br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex_direction2.png?raw=true" alt=""></p><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于指定Flex子项是否换行</span><br><span class="line"></span><br><span class="line">取值：nowrap | wrap | wrap-reverse</span><br></pre></td></tr></table></figure><ul><li>nowrap：默认值，表示不换行，Flex子项可能会溢出</li><li>wrap：表示换行，溢出的Flex子项会被放到下一行</li><li>wrap-reverse：表示反方向换行<br>flex-wrap三种取值的效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex_warp.png?raw=true" alt=""></li></ul><p>从示例图中不难发现，换行以后两行之间产生了很大的间距，这个问题，在后面介绍的 align-content 属性中可以得到很好的解决。</p><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>复合属性，是flex-direction 和 flex-wrap 的简写属性，是用于指定Flex子项的排列方式</p><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>用于指定主轴(水平方向)上Flex子项的对齐方式<br>取值：flex-start | flex-end | center | space-between | space-around</p><ul><li>flex-start：默认值，表示与行的起始位置对齐</li><li>flex-end：表示与行的结束位置对齐</li><li>center：表示与行中间对其</li><li>space-between：表示两端对齐，中间间距相等。要注意特殊情况，当剩余空间为负数或者只有一个项时，效果等同于flex-start</li><li>space-around：表示间距相等，中间间距是两端间距的2倍。要注意特殊情况，当剩余空间为负数或者只有一个项时，效果等同于center</li></ul><p>justify-content 的前三种取值的效果图如下：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/justify-content.png?raw=true" alt=""><br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/justify-content1.png?raw=true" alt=""><br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/justify-content2.png?raw=true" alt=""></p><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于指定侧轴(垂直方向)上Flex子项的对齐方式</span><br><span class="line">取值：stretch | flex-start | flex-end | center | baseline</span><br></pre></td></tr></table></figure><ul><li>stretch：默认值，当Flex子项未设置高度或者高度值为auto时，stretch起作用，将Flex子项高度设置为行高度。这里需要注意，在只有一行的情况下，行的高度为容器的高度，即Flex子项高度为容器的高度</li><li>flex-start：表示与侧轴开始位置对齐</li><li>flex-end：表示与侧轴的结束位置对齐</li><li>center：表示与侧轴中间对其</li><li>baseline：表示基线对齐，当行内轴与侧轴在同一线上，即所有Flex子项的基线在同一线上时，效果等同于flex-start</li></ul><p>align-items 取值为 stretch 的效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/align1.png?raw=true" alt=""></p><p>align-items 取值为 flex-start flex-end center 的效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/align2.png?raw=true" alt=""></p><p>align-items 取值为 baseline 的效果图如下：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/align1.png?raw=true" alt=""></p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该属性只作用于多行的情况下，用于多行的对齐方式</span><br><span class="line">取值：stretch | flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure><ul><li>stretch：默认值，当Flex子项未设置高度或者高度值为auto时，stretch起作用，将Flex子项高度设置为行高度。</li><li>flex-start：表示各行与侧轴开始位置对齐，第一行紧靠侧轴开始边界，之后的每一行都紧靠前面一行</li><li>flex-end：表示各行与侧轴的结束位置对齐，最后一行紧靠侧轴结束边界，之后的每一行都紧靠前面一行</li><li>center：表示各行与侧轴中间对其</li><li>space-between：表示两端对齐，中间间距相等。要注意特殊情况，当剩余空间为负数时，效果等同于flex-start</li><li>space-around：表示各行之间间距相等，中间间距是两端间距的2倍。要注意特殊情况，当剩余空间为负数时，效果等同于center</li></ul><p>再次强调：该属性只作用于多行的情况，在只有一行的Flex容器上无效，另外该属性可以很好的处理，换行以后相邻行之间产生的间距。</p><p>align-content 各个取值的效果图如下：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/aligin4.png?raw=true" alt=""></p><h2 id="Flex-作用于子项上的6个属性介绍"><a href="#Flex-作用于子项上的6个属性介绍" class="headerlink" title="Flex 作用于子项上的6个属性介绍"></a>Flex 作用于子项上的6个属性介绍</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>该属性用来指定Flex子项的排列顺序，数值越小，越靠前，可以为负数<br>取值：数值，默认值为0</p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>用来指定Flex子项的扩展比例，不可以为负数，Flex容器会根据Flex子项设置的扩展比例作为比率来分配剩余空间<br>取值：数值，默认值为0，表示即使存在剩余空间，Flex子项也不会扩展<br>如下图中，按照1:3分配剩余空间：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex-grow.png?raw=true" alt=""></p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>用来指定Flex子项的收缩比例，不可以为负数，Flex容器会根据Flex子项设置的收缩比例作为比率来收缩各个Flex子项<br>取值：数值，默认值为1，表示所有子项在剩余空间为负数时，等比例收缩<br>注意：flex-shrink只能在不换行的情况下使用<br>如下图中，按照1:3收缩：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex-shrink.png?raw=true" alt=""></p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来指定Flex子项的占据的空间，不可以为负数</span><br><span class="line">取值：auto | length | percentage | content</span><br></pre></td></tr></table></figure><ul><li>auto：默认值，计算规则：检索Flex子项是否设置了width值（或者height值，取决于flex-direction），如果设置了非auto的值，则使用width值（或者height值），若没有则使用content</li><li>length：用长度值定义宽度，不可为负数</li><li>percentage：使用百分比定义宽度，不可为负数<br>如下图中，为Item设置 flex-basis: 50%; ,在按照1:3分配剩余空间：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/flex-basics.png?raw=true" alt=""></li></ul><p>容器宽度为200px，Item1原始宽度为50px，设置 flex-basis: 50%;后宽度变成100px，扩展后宽度为110.5px；而Item2原始宽度为50px，扩展后为81.5px，比例正好是1:3<br>注意：</p><ol><li>设置flex-grow进行分配剩余空间，或者使用flex-shrink进行收缩都是在flex-basis的基础上进行的； </li><li>当flex-basis的值以及width（或者height）的值均为非auto时，</li></ol><ul><li>若content长度同时大于flex-basis的值以及width（或者height）的值，此时以flex-basis与width（或者height）中值大的为准 ，但是，如果子项设置了overflow: hidden;或者overflow: auto;，此时以flex-basis值为准；</li><li>若content长度同时小于flex-basis的值以及width（或者height）的值，此时以flex-basis值为准；</li><li>若content长度小于flex-basis的值，大于width（或者height）的值，此时以flex-basis值为准；</li><li>若content长度大于flex-basis的值，小于width（或者height）的值，此时以content自身长度值为准；</li></ul><p>3.当width（或者height）的值为auto时，且内容的长度大于flex-basis设置的值，此时以content自身长度值为准，且不能进行flex-shrink收缩。相反如果内容的长度小于flex-basis设置的值，则会使用flex-basis设置的值；<br>4.当存在最小值 min-width（min-height）时，且 flex-basis的值小于最小值时，宽度以最小值为准，当 flex-basis的值大于最小值时，以 flex-basis的值为准</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复合属性，是flex-grow 、 flex-shrink 和 flex-basis 的简写属性，用来指定Flex子项如何分配空间</span><br><span class="line">取值：none | 各拆分项属性</span><br></pre></td></tr></table></figure><ul><li>none：0 0 auto</li><li>auto：1 1 auto</li><li>1：1 1 0%</li><li>0 auto 或 initial：0 1 auto 即初始值</li></ul><p>注意：</p><ul><li>flex-grow：默认值为0，若省略则被默认为1</li><li>flex-shrink：默认值为1，省略时默认为1</li><li>flex-basis：默认值为auto，省略时默认为0%</li></ul><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来单独指定某Flex子项的对齐方式</span><br><span class="line">取值：auto | flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure><ul><li>auto：默认值，查找父元素的align-items值，如果没有则取值为stretch</li><li>其他值同align-items</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/5323146.html#anchor4-1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;flex盒子模型&lt;/a&gt;;&lt;/p&gt;
&lt;h2 id=&quot;Flex布局&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>Jquery-详解</title>
    <link href="http://yoursite.com/2018/05/14/Jquery-%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/14/Jquery-详解/</id>
    <published>2018-05-14T08:30:51.000Z</published>
    <updated>2018-05-14T08:31:42.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JQuery-效果"><a href="#JQuery-效果" class="headerlink" title="JQuery 效果"></a>JQuery 效果</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JQuery-效果&quot;&gt;&lt;a href=&quot;#JQuery-效果&quot; class=&quot;headerlink&quot; title=&quot;JQuery 效果&quot;&gt;&lt;/a&gt;JQuery 效果&lt;/h2&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>音频概述</title>
    <link href="http://yoursite.com/2018/05/14/%E9%9F%B3%E9%A2%91%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2018/05/14/音频概述/</id>
    <published>2018-05-14T06:35:47.000Z</published>
    <updated>2018-05-14T06:47:49.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="音频简述"><a href="#音频简述" class="headerlink" title="音频简述"></a>音频简述</h2><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>先来简单了解一下一些基础的音频知识。</p><p>目前我们在计算机上进行音频播放都需要依赖于音频文件，音频文件的生成过程是将声音信息采样、量化和编码产生的数字信号的过程，人耳所能听到的声音，最低的频率是从20Hz起一直到最高频率20KHZ，因此音频文件格式的最大带宽是20KHZ。根据奈奎斯特的理论，只有采样频率高于声音信号最高频率的两倍时，才能把数字信号表示的声音还原成为原来的声音，所以音频文件的采样率一般在40~50KHZ，比如最常见的CD音质采样率44.1KHZ。</p><p>对声音进行采样、量化过程被称为脉冲编码调制（Pulse Code Modulation），简称PCM。PCM数据是最原始的音频数据完全无损，所以PCM数据虽然音质优秀但体积庞大，为了解决这个问题先后诞生了一系列的音频格式，这些音频格式运用不同的方法对音频数据进行压缩，其中有无损压缩（ALAC、APE、FLAC）和有损压缩（MP3、AAC、OGG、WMA）两种。</p><p>目前最为常用的音频格式是MP3，MP3是一种有损压缩的音频格式，设计这种格式的目的就是为了大幅度的减小音频的数据量，它舍弃PCM音频数据中人类听觉不敏感的部分，从下面的比较图我们可以明显的看到MP3数据相比PCM数据明显矮了一截（图片引自imp3论坛）。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioPcm.jpg?raw=true" alt=""><br>上图为pcm数据<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioMp3.jpg?raw=true" alt=""><br>上图为mp3数据</p><p>MP3格式中的码率（BitRate）代表了MP3数据的压缩质量，现在常用的码率有128kbit/s、160kbit/s、320kbit/s等等，这个值越高声音质量也就越高。MP3编码方式常用的有两种固定码率(Constant bitrate，CBR)和可变码率(Variable bitrate，VBR)。<br>MP3格式中的数据通常由两部分组成，一部分为ID3用来存储歌名、演唱者、专辑、音轨数等信息，另一部分为音频数据。音频数据部分以帧(frame)为单位存储，每个音频都有自己的帧头，如图所示就是一个MP3文件帧结构图（图片同样来自互联网）。MP3中的每一个帧都有自己的帧头，其中存储了采样率等解码必须的信息，所以每一个帧都可以独立于文件存在和播放，这个特性加上高压缩比使得MP3文件成为了音频流播放的主流格式。帧头之后存储着音频数据，这些音频数据是若干个PCM数据帧经过压缩算法压缩得到的，对CBR的MP3数据来说每个帧中包含的PCM数据帧是固定的，而VBR是可变的。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/cbr.jpg?raw=true" alt=""></p><h2 id="iOS音频播放概述"><a href="#iOS音频播放概述" class="headerlink" title="iOS音频播放概述"></a>iOS音频播放概述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">了解了基础概念之后我们就可以列出一个经典的音频播放流程（以MP3为例）：</span><br><span class="line">1.读取MP3文件</span><br><span class="line">2.解析采样率、码率、时长等信息，分离MP3中的音频帧</span><br><span class="line">3.对分离出来的音频帧解码得到PCM数据</span><br><span class="line">4.对PCM数据进行音效处理（均衡器、混响器等，非必须）</span><br><span class="line">5.把PCM数据解码成音频信号</span><br><span class="line">6.把音频信号交给硬件播放</span><br><span class="line">7.重复1-6步直到播放完成</span><br></pre></td></tr></table></figure><p>在iOS系统中apple对上述的流程进行了封装并提供了不同层次的接口</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audio_service.jpg?raw=true" alt=""><br>CoreAudio的接口层次</p><p>下面对其中的中高层接口进行功能说明：</p><ul><li>Audio File Services：读写音频数据，可以完成播放流程中的第2步；</li><li>Audio File Stream Services：对音频进行解码，可以完成播放流程中的第2步；</li><li>Audio Converter services：音频数据转换，可以完成播放流程中的第3步；</li><li>Audio Processing Graph Services：音效处理模块，可以完成播放流程中的第4步；</li><li>Audio Unit Services：播放音频数据：可以完成播放流程中的第5步、第6步；</li><li>Extended Audio File Services：Audio File Services和Audio Converter services的结合体；</li><li>AVAudioPlayer/AVPlayer(AVFoundation)：高级接口，可以完成整个音频播放的过程（包括本地文件和网络流播放，第4步除外）；</li><li>Audio Queue Services：高级接口，可以进行录音和播放，可以完成播放流程中的第3、5、6步；</li><li>OpenAL：用于游戏音频播放，暂不讨论,可以看到apple提供的接口类型非常丰富，可以满足各种类别类需求：</li><li>如果你只是想实现音频的播放，没有其他需求AVFoundation会很好的满足你的需求。它的接口使用简单、不用关心其中的细节； +         如果你的app需要对音频进行流播放并且同时存储，那么AudioFileStreamer加AudioQueue能够帮到你，你可以先把音频数据下载到本地，一边下载一边用NSFileHandler等接口读取本地音频文件并交给AudioFileStreamer或者AudioFile解析分离音频帧，分离出来的音频帧可以送给AudioQueue进行解码和播放。如果是本地文件直接读取文件解析即可。（这两个都是比较直接的做法，这类需求也可以用AVFoundation+本地server的方式实现，AVAudioPlayer会把请求发送给本地server，由本地server转发出去，获取数据后在本地server中存储并转送给AVAudioPlayer。另一个比较trick的做法是先把音频下载到文件中，在下载到一定量的数据后把文件路径给AVAudioPlayer播放，当然这种做法在音频seek后就回有问题了。）； +     如果你正在开发一个专业的音乐播放软件，需要对音频施加音效（均衡器、混响器），那么除了数据的读取和解析以外还需要用到AudioConverter来把音频数据转换成PCM数据，再由AudioUnit+AUGraph来进行音效处理和播放（但目前多数带音效的app都是自己开发音效模块来坐PCM数据的处理，这部分功能自行开发在自定义性和扩展性上会比较强一些。PCM数据通过音效器处理完成后就可以使用AudioUnit播放了，当然AudioQueue也支持直接使对PCM数据进行播放。）。</li></ul><p>下图描述的就是使用AudioFile + AudioConverter + AudioUnit进行音频播放的流程（图片引自官方文档）<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/audioUnitPlay.jpg?raw=true" alt=""> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;音频简述&quot;&gt;&lt;a href=&quot;#音频简述&quot; class=&quot;headerlink&quot; title=&quot;音频简述&quot;&gt;&lt;/a&gt;音频简述&lt;/h2&gt;&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
  <entry>
    <title>linux文件复用</title>
    <link href="http://yoursite.com/2018/05/14/linux%E6%96%87%E4%BB%B6%E5%A4%8D%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/14/linux文件复用/</id>
    <published>2018-05-14T05:52:56.000Z</published>
    <updated>2018-05-14T06:34:22.771Z</updated>
    
    <content type="html"><![CDATA[<p>本文摘自<a href="https://blog.csdn.net/colzer/article/details/8169075" target="_blank" rel="noopener">Linux网络编程</a></p><p># </p><h2 id="IO概念"><a href="#IO概念" class="headerlink" title="IO概念"></a>IO概念</h2><p>Linux的内核将所有外部设备都可以看做一个文件来操作。那么我们对与外部设备的操作都可以看做对文件进行操作。我们对一个文件的读写，都通过调用内核提供的系统调用；内核给我们返回一个file descriptor（fd,文件描述符）。而对一个socket的读写也会有相应的描述符，称为socketfd(socket描述符）。描述符就是一个数字，指向内核中一个结构体（文件路径，数据区，等一些属性）。那么我们的应用程序对文件的读写就通过对描述符的读写完成。<br> linux将内存分为内核区，用户区。linux内核给我们管理所有的硬件资源，应用程序通过调用系统调用和内核交互，达到使用硬件资源的目的。应用程序通过系统调用read发起一个读操作，这时候内核创建一个文件描述符，并通过驱动程序向硬件发送读指令，并将读的的数据放在这个描述符对应结构体的内核缓存区中，然后再把这个数据读到用户进程空间中，这样完成了一次读操作；<br>但是大家都知道I/O设备相比cpu的速度是极慢的。linux提供的read系统调用，也是一个阻塞函数。这样我们的应用进程在发起read系统调用时，就必须阻塞，就进程被挂起而等待文件描述符的读就绪，那么什么是文件描述符读就绪，什么是写就绪？<br>读就绪：就是这个文件描述符的接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小；<br>写就绪：该描述符发送缓冲区的可用空间字节数大于等于描述符发送缓冲区低水位标记的当前大小。（如果是socket fd，说明上一个数据已经发送完成）。<br>接收低水位标记和发送低水位标记：由应用程序指定，比如应用程序指定接收低水位为64个字节。那么接收缓冲区有64个字节，才算fd读就绪；<br>综上所述，一个基本的IO，它会涉及到两个系统对象，一个是调用这个IO的进程对象，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过read系统调用想内核发起读请求。</span><br><span class="line">2.内核向硬件发送读指令，并等待读就绪。 </span><br><span class="line">3.内核把将要读取的数据复制到描述符所指向的内核缓存区中。</span><br><span class="line">4.将数据从内核缓存区拷贝到用户进程空间中。</span><br></pre></td></tr></table></figure></p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>在linux系统下面，根据IO操作的是否被阻塞以及同步异步问题进行分类，可以得到下面五种IO模型：</p><h3 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h3><p>最流行的I/O模型是阻塞I/O模型，缺省情形下，所有文件操作都是阻塞的。我们以套接口为例来讲解此模型。在进程空间中调用recvfrom，其系统调用直到数据报到达且被拷贝到应用进程的缓冲区中或者发生错误才返回，期间一直在等待。我们就说进程在从调用recvfrom开始到它返回的整段时间内是被阻塞的。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/IO.jpg?raw=true" alt=""></p><h3 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h3><p>进程把一个套接口设置成非阻塞是在通知内核：当所请求的I/O操作不能满足要求时候，不把本进程投入睡眠，而是返回一个错误。也就是说当数据没有到达时并不等待，而是以一个错误返回。</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/IO1.jpg?raw=true" alt=""></p><h3 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h3><p>linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select;这样select/poll可以帮我们侦测许多fd是否就绪。但是select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限。linux还提供了一个epoll系统调用，epoll是基于事件驱动方式，而不是顺序扫描,当有fd就绪时，立即回调函数rollback；<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io3.jpg?raw=true" alt=""></p><h3 id="信号驱动异步I-O模型"><a href="#信号驱动异步I-O模型" class="headerlink" title="信号驱动异步I/O模型"></a>信号驱动异步I/O模型</h3><p>首先开启套接口信号驱动I/O功能, 并通过系统调用sigaction安装一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据报准备好被读时，就为该进程生成一个SIGIO信号。随即可以在信号处理程序中调用recvfrom来读数据报，井通知主循环数据已准备好被处理中。也可以通知主循环，让它来读数据报。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io4.jpg?raw=true" alt=""></p><h3 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h3><p>告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核拷贝到用户自己的缓冲区)通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O：由内核通知我们何时可以启动一个I/O操作；异步I/O模型：由内核通知我们I/O操作何时完成。<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/io5.jpg?raw=true" alt=""></p><h2 id="非阻塞IO详解"><a href="#非阻塞IO详解" class="headerlink" title="非阻塞IO详解"></a>非阻塞IO详解</h2><p>在IO编程过程中，当需要处理多个请求的时，可以使用多线程和IO复用的方式进行处理。上面的图介绍了整个IO复用的过程，它通过把多个IO的阻塞复用到一个select之类的阻塞上，从而使得系统在单线程的情况下同时支持处理多个请求。和多线程/进程比较，I/O多路复用的最大优势是系统开销小，系统不需要建立新的进程或者线程，也不必维护这些线程和进程。IO复用常见的应用场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户程序需要同时处理交互式的输入和服务器之间的网络连接。</span><br><span class="line">客户端需要对多个网络连接作出反应。</span><br><span class="line">服务器需要同时处理多个处于监听状态和多个连接状态的套接字</span><br><span class="line">服务器需要处理多种网络协议的套接字。</span><br></pre></td></tr></table></figure></p><p>目前支持I/O复用的系统调用有select、pselect、poll、epoll，下面几小结分别来学习一下select和epoll的使用。</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt;  </span><br><span class="line">int select(int maxfdps, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);  </span><br><span class="line">struct timeval&#123;  </span><br><span class="line">   long tv_sec; //秒  </span><br><span class="line">long tv_usec; //微秒  </span><br><span class="line">&#125;;  </span><br><span class="line">void FD_CLR(int fd, fd_set *set); //将一个给定的文件描述符从集合中删除  int  FD_ISSET(int fd, fd_set *set);  // 检查集合中指定的文件描述符是否可以读写 ?  </span><br><span class="line">void FD_SET(int fd, fd_set *set); //将一个给定的文件描述符加入集合之中  </span><br><span class="line">void FD_ZERO(fd_set *set);//清空集合</span><br></pre></td></tr></table></figure><p>struct timeval <em>time结构体告知内核等待所指定描述字中的任何一个就绪可花多少时间。参数取值：<br>（1）(struct timeval </em>)0：永远等待下去，仅在有一个描述字准备好I/O时才返回。<br>（2）struct timeval *time：在有一个描述字准备好I/O时返回，但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数。如果超过时间，没有描述字准备好，那就返回0。如果秒=微秒=0，检查描述字后立即返回，此时相当于轮询。<br>中间的三个参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述字。如果我们对某一个的条件不感兴趣，就可以把它设为空指针。fd_set可以理解为一个集合，这个集合中存放的是文件描述符，可通过上面的四个宏进行设置（注意，fd_set不是struct fd_set。。。 刚刚开始调试程序就犯错误，返回storage size of ‘fds’ isn’t known）。<br>第一个参数maxfdp1指定待测试的描述字个数，它的值是待测试的最大描述字加1（因此我们把该参数命名为maxfdp1），描述字0、1、2…maxfdp1-1均将被测试。</p><h3 id="pselect"><a href="#pselect" class="headerlink" title="pselect"></a>pselect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/select.h&gt; </span><br><span class="line"> int pselect(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, const struct timespec *timeout, const sigset_t *sigmask);  </span><br><span class="line">struct timespec&#123;  </span><br><span class="line">time_t tv_sec; //秒  </span><br><span class="line">long tv_nsec; //纳秒  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较select和pselect函数，我们发现在原型上面有两个不同：<br>1、pselect使用timespec结构，而不使用timeval结构。timespec结构是POSIX的又一个发明。 这两个结构的区别在于第二个成员：新结构的该成员tv_nsec指定纳秒数，而旧结构的该成员tv_usec指定微秒数。<br>2、pselect函数增加了第六个参数：一个指向信号掩码的指针。该参数允许程序先禁止递交某些信号，再测试由这些当前被禁止的信号处理函数设置的全局变量，然后调用pselect，告诉它重新设置信号掩码。<br>首先我们看看信号掩码的概念：在POSIX下，每个进程有一个信号掩码(signal mask)。简单地说，信号掩码是一个“位图”，其中每一位都对应着一种信号。如果位图中的某一位为1，就表示在执行当前信号的处理程序期间相应的信号暂时被“屏蔽”，使得在执行的过程中不会嵌套地响应那种信号。为什么对某一信号进行屏蔽呢？我们来看一下对CTRL_C的处理。大家知道，当一个程序正在运行时，在键盘上按一下CTRL_C，内核就会向相应的进程发出一个SIGINT 信号，而对这个信号的默认操作就是通过do_exit()结束该进程的运行。但是，有些应用程序可能对CTRL_C有自己的处理，所以就要为SIGINT另行设置一个处理程序，使它指向应用程序中的一个函数，在那个函数中对CTRL_C这个事件作出响应。但是，在实践中却发现，两次CTRL_C事件往往过于密集，有时候刚刚进入第一个信号的处理程序，第二个SIGINT信号就到达了，而第二个信号的默认操作是杀死进程，这样，第一个信号的处理程序根本没有执行完。为了避免这种情况的出现，就在执行一个信号处理程序的过程中将该种信号自动屏蔽掉。所谓“屏蔽”，与将信号忽略是不同的，它只是将信号暂时“遮盖”一下，一旦屏蔽去掉，已到达的信号又继续得到处理。有关信号相关的知识参考我另外一个文章：<a href="https://blog.csdn.net/colzer/article/details/8135542" target="_blank" rel="noopener">《linux基础编程：进程通信之信号》</a>。在我们开发过程中，如果进程阻塞与select函数，此时该阻塞被信号所打断，select返回-1，errno=EINTR的错误。由于这个原因，我们才有了pselect函数在信号上的优化处理。因此在信号和select都被使用的系统里，pselect有其作用。否则和select没有任何区别。</p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;    </span><br><span class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);  </span><br><span class="line">struct pollfd &#123;  </span><br><span class="line">int fd; /* file descriptor */  </span><br><span class="line">short events; </span><br><span class="line">/* requested events to watch */  </span><br><span class="line">short revents; </span><br><span class="line">/* returned events witnessed */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和select()不一样，poll()没有使用低效的三个基于位的文件描述符set，而是采用了一个单独的结构体pollfd数组，由fds指针指向这个数组的第一个元素，其中nfds表示该数组的大小。每一个pollfd 结构体指定了一个被监视的文件描述符，每个结构体的events域是监视该文件描述符的事件掩码，由用户来设置这个域。revents域是文件描述符的操作结果事件掩码。内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回，而部分事件不能出现在events中，详细如下表。</p><table><thead><tr><th>常量</th><th>说明</th></tr></thead><tbody><tr><td>POLLIN</td><td>普通或优先级带数据可读</td></tr><tr><td>POLLRDNORM</td><td>普通数据可读</td></tr><tr><td>POLLRDBAND</td><td>优先级带数据可读</td></tr><tr><td>POLLPRI</td><td>高优先级数据可读</td></tr><tr><td>POLLOUT</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>普通数据可写</td></tr><tr><td>POLLWRBAND</td><td>优先级带数据可写</td></tr><tr><td>POLLERR</td><td>发生错误</td></tr><tr><td>POLLHUP</td><td>发生挂起</td></tr><tr><td>POLLNVAL</td><td>描述字不是一个打开的文件</td></tr></tbody></table> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：后三个只能作为描述字的返回结果存储在revents中，而不能作为测试条件用于events中。</span><br></pre></td></tr></table></figure><p> 最后一个参数timeout是指定poll函数返回前等待多长时间。它的取值如下：</p><table><thead><tr><th>timeout值</th><th>说明</th></tr></thead><tbody><tr><td>INFTIM</td><td>永远等待</td></tr><tr><td>0</td><td>立即返回，不阻塞进程</td></tr><tr><td>＞0</td><td>等待指定数目的毫秒数</td></tr></tbody></table><p> 成功时，poll()返回结构体中revents域不为0的文件描述符个数；如果在超时前没有任何事件发生，poll()返回0；失败时，poll()返回-1，并设置errno为下列值之一：<br>EBADF：一个或多个结构体中指定的文件描述符无效。EFAULT：fds指针指向的地址超出进程的地址空间。EINTR：请求的事件之前产生一个信号，调用可以重新发起。EINVAL：nfds参数超出PLIMIT_NOFILE值。ENOMEM：可用内存不足，无法完成请求。<br>关键代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client[0].fd = listenfd;         /*将数组中的第一个元素设置成监听描述字*/  </span><br><span class="line">client[0].events = POLLIN;    </span><br><span class="line">while(1)  &#123;  </span><br><span class="line">nready = poll(client, maxi+1,INFTIM); //将进程阻塞在poll上  </span><br><span class="line">if( client[0].revents &amp; POLLIN/*POLLRDNORM*/ ) </span><br><span class="line">/*先测试监听描述字*/</span><br></pre></td></tr></table></figure><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>在linux的网络编程中，很长的一段时间都在使用select来做事件触发。然而select逐渐暴露出了一些缺陷，使得linux不得不在新的内核中寻找出替代方案，那就是epoll。其实，epoll与select原理类似，只不过，epoll作出了一些重大改进，即：<br>1.支持一个进程打开大数目的socket描述符(FD)<br>select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。<br>2.IO效率不随FD数目增加而线性下降<br>传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的，但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。<br>3.使用mmap加速内核与用户空间的消息传递。<br>这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。<br>4.内核微调<br>这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 — 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网卡驱动架构。</p><p>epoll api函数比较简单，包括创建一个epoll描述符，添加监听事件，阻塞等待所监听的事件发生,关闭epoll描述符，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">int epoll_create(int size); </span><br><span class="line">//epoll描述符  </span><br><span class="line">int close(int fd);//关闭epoll描述符</span><br></pre></td></tr></table></figure><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。需要注意的是，当创建好epoll句柄后，epoll本身就占用一个fd值，所以用完后必须调用close()关闭，以防止fd被耗尽。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;    </span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);//添加监听事件  </span><br><span class="line">  </span><br><span class="line">typedef union epoll_data &#123;  </span><br><span class="line">  void  *ptr;  </span><br><span class="line">  int   fd;  </span><br><span class="line">  uint32_t  u32;  </span><br><span class="line">  uint64_t  u64;  </span><br><span class="line">&#125; epoll_data_t;  </span><br><span class="line">  </span><br><span class="line">struct epoll_event &#123;  </span><br><span class="line">   uint32_t events;     </span><br><span class="line">   /* Epoll events */  </span><br><span class="line">   epoll_data_t data;        </span><br><span class="line">   /* User data variable */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>epoll_ctl为事件注册函数，第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p><ul><li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li><li>EPOLL_CTL_DEL：从epfd中删除一个fd;<br>第三个参数是需要监听的描述符fd,第四个参数是告诉内核需要监听什么事件，struct epoll_event结构如上所示，其中events为需要注册的事件，可以为下面几个宏的集合：</li><li>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</li><li>EPOLLOUT：表示对应的文件描述符可以写；</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</li><li>EPOLLERR：表示对应的文件描述符发生错误；</li><li>EPOLLHUP：表示对应的文件描述符被挂断；</li><li>EPOLLET：将EPOLL设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。详细见下面描述</li><li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</li></ul><p>操作系统对被注册的文件描述符的事件发送以后有两种处理方式，分别有LT和ET模式，默认情况下为LT，如果需要设置为ET模式，设置struct epoll_event.events|EPOLLET。</p><ul><li>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点，传统的select/poll都是这种模型的代表。</li><li>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once),不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。</li></ul><p>struct epoll_event.data为一个epoll_data_t类型的联合体，详细结构如上，其中可以保存指针，描述符，32/64位的整数。如果在监听过程中，该描述符上面有相应的事件发生，系统将会把该字段返回。先看监听函数吧。看完就知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);//阻塞等待所监听的事件发生</span><br></pre></td></tr></table></figure><p>阻塞监听函数，类似于select()调用。参数events用来从内核得到事件的集合，返回的结构也是struct epoll_event，其中event为相应的事件，data为注册时，设置的值（常见情况，data设置为注册的描述符，这样就可以对相应的描述符进行IO操作）。maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><p>最后我们说一下，用来克服select/poll缺点的方法不只有epoll。epoll只是一种linux 的方案，在freeBSD下有kqueue，而dev/poll 是最古老的Solaris的方案，使用难度依次递增。 kqueue 是freebsd 的宠儿，kqueue 实际上是一个功能相当丰富的kernel 事件队列，它不仅仅是select/poll 的升级，而且可以处理 signal 、目录结构变化、进程等多种事件。Kqueue 是边缘触发的。/dev/poll 是Solaris的产物，是这一系列高性能API 中最早出现的。Kernel 提供一个特殊的设备文件/dev/poll 。应用程序打开这个文件得到操纵fd_set 的句柄，通过写入pollfd 来修改它，一个特殊ioctl 调用用来替换select 。由于出现的年代比较早，所以/dev/poll 的接口现在看上去比较笨拙可笑。</p><h2 id="信号驱动异步IO详解"><a href="#信号驱动异步IO详解" class="headerlink" title="信号驱动异步IO详解"></a>信号驱动异步IO详解</h2><p>上面介绍了不管是阻塞/非阻塞或者IO复用，在应用程序层面都需要进行阻塞轮询指定的IO上面是否有相应的事件发生。本节我们将将介绍一个全新的模型：异步模型，异步则意味着不需要用户层进行轮询，在特定IO或者事件发生时候，会主动通知应用程序IO就绪，本节介绍的通知机制即信号，我们把这个模型叫着信号驱动的异步I/O。在《linux基础编程：进程通信之信号》文章中，我们详细介绍信号操作。<br>Unix上有定义了许多信号，源自Berkeley的实现使用的是SIGIO信号来支持套接字和终端设备上的信号驱动IO。在套接字IO中，信号驱动IO模型主要是在UDP套接字上使用，在TCP套接字上几乎是没有什么使用的（在TCP上，由于TCP是双工的，它的信号产生过于平凡，并且信号的出现几乎没有告诉我们发生了什么事情。因此对于TCP套接字，SIGIO信号是没有什么使用的）。<br>使用信号驱动异步IO主要有下面几个步骤：<br>为了让套接字描述符可以工作于信号驱动I/O模式，应用进程必须完成如下三步设置： </p><ul><li>1.注册SIGIO信号处理程序。(安装信号处理器) </li><li>2.使用fcntl的F_SETOWN命令，设置套接字所有者。 </li><li>3.使用fcntl的F_SETFL命令，置O_ASYNC和O_NONBLOCK标志，允许套接字信号驱动I/O。</li></ul><p>注意，必须保证在设置套接字所有者之前，向系统注册信号处理程序，否则就有可能在fcntl调用后，信号处理程序注册前内核向应用交付SIGIO信号，导致应用丢失此信号。<br>代码片段如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction sigio_action;  </span><br><span class="line">memset(&amp;sigio_action, 0, sizeof(sigio_action));  </span><br><span class="line">sigio_action.sa_flags = 0;  </span><br><span class="line">sigio_action.sa_handler = do_sigio;</span><br><span class="line">//信号发生时的处理函数  </span><br><span class="line">sigaction(SIGIO, &amp;sigio_action, NULL);  </span><br><span class="line">fcntl(listenfd1, F_SETOWN, getpid());  </span><br><span class="line">int flags;  </span><br><span class="line">flags = fcntl(listenfd1, F_GETFL, 0);  </span><br><span class="line">flags |= O_ASYNC | O_NONBLOCK;  </span><br><span class="line">fcntl(listenfd1, F_SETFL, flags);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文摘自&lt;a href=&quot;https://blog.csdn.net/colzer/article/details/8169075&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux网络编程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;IO概
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>RunLoop-事件循环对象</title>
    <link href="http://yoursite.com/2018/05/14/RunLoop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/05/14/RunLoop-事件循环对象/</id>
    <published>2018-05-14T02:50:58.000Z</published>
    <updated>2018-05-14T05:48:11.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop-的基本概念"><a href="#RunLoop-的基本概念" class="headerlink" title="RunLoop 的基本概念"></a>RunLoop 的基本概念</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1、runloop是什么-————-O"><a href="#1、runloop是什么-————-O" class="headerlink" title="1、runloop是什么? ———— O"></a>1、runloop是什么? ———— O</h4><p>   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比<br> 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：do {//接受消息-&gt;等待-&gt;处理}while(message != quit)线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结&gt; 束（比如传入 quit 的<br>消息），函数返回。</p><h4 id="没有runloop会怎样？"><a href="#没有runloop会怎样？" class="headerlink" title="没有runloop会怎样？"></a>没有runloop会怎样？</h4><p>上面这样的运行机制通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，<br>比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。<br>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>如果iOS APP 没有runloop 机制会怎么样呢？<br>如果没有runloop的机制的话，我们的app，从一启动到退出程序时间会很短。<br>更加形象的说，app一启动就死了。<br>所以，runloop 的存在，就是保住app的生命，让app 可以随时待命，处理用户的操作以及其他事件。<br>runloop的重要性就在于：我们控制了runloop ,就是控制了app 的生死</p><h2 id="RunLoop-相关类以及构成要素"><a href="#RunLoop-相关类以及构成要素" class="headerlink" title="RunLoop 相关类以及构成要素"></a>RunLoop 相关类以及构成要素</h2><h3 id="runloop-相关类"><a href="#runloop-相关类" class="headerlink" title="runloop 相关类"></a>runloop 相关类</h3><p>在 iOS 中，RunLoop 就是个对象。<br>众所周知，OC 语言是对于 C 的封装。所以呢，会有两个框架，一个是 CoreFoundation，一个是面向对象的 Foundation。<br>全文在解释原理的时候，是直接使用底层 CoreFoundation 的源码解释。</p><p>在 CoreFoundation 框架为 CFRunLoopRef 对象，它提供了纯 C 函数的 API，并且这些 API 是线程安全的；<br>而在 Foundation 框架中用 NSRunLoop 对象来表示，它是基于 CFRunLoopRef 的封装，提供的是面向对象的 API，但这些 API 不是线程安全的。<br>CFRunLoopRef 的代码是开源的，我们可以在 这里 或 这里 找到 CFRunLoop.c 来查看 RunLoop 的源码。</p><h3 id="构成元素"><a href="#构成元素" class="headerlink" title="构成元素"></a>构成元素</h3><p>在 CoreFoundation 中关于 RunLoop 有 5 个类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure><p>一个Runloop对应一条线程，一个runloop里面可以有多个CFRunLoopModeRef(模式）。<br>同一个时刻，RunLoop只能是在一个mode上面的运行。如果需要切换mode,只能是退出currentMode ,切换到指定的 mode 。<br>每一个mode又可以包含多个 source/timer/observer。不同 mode 里面的子元素，互不影响。</p><p>5个类的对应关系大概是：</p><p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop.png?raw=true" alt=""></p><p>下面具体介绍这个CFRunLoop里面的4个类。</p><h4 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h4><p>官方文档介绍如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified.</span><br><span class="line">You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.</span><br><span class="line">You use modes to filter out events from unwanted sources during a particular pass through your run loop.</span><br></pre></td></tr></table></figure></p><p>即一个 run loop mode 是若干个 source、timer 和 observer 的集合。它能帮我们过滤掉一些不想要的事件。</p><p>即一个 RunLoop 在某个 mode 下运行时，不会接收和处理其他 mode 的事件 </p><p>要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer 。</p><p>这一点很容易理解，你想啊，如果一个 mode 里面什么东西都没有，那么他根本就没有活干，那 mode 活着还有什么意思。</p><p>苹果公开的 mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode。</p><p>前者是默认的模式，程序运行的大多时候都处于该 mode 下，后者是滑动 tableView 或 scrollerView 时为了界面流畅而用的 mode。</p><p>还有个 UIInitializationRunLoopMode 是程序启动时进入的 mode，一般用不上。<br>以上，两个公开常用的 mode, 在执行的时候，相互独立，互不干扰。</p><p>这样让不同的mode各司其职，对于程序运行的解耦很有好处。<br>但是如果偏偏想要让两个互相不干扰的mode,都做同一件事情可以实现么？<br>可以实现的。苹果爸爸，想到了这一点。<br>CFRunLoop里面有一个伪mode叫做 kCFRunLoopCommonModes，它不是一个真正的 mode，而是若干个 mode 的集合。<br>你可以把这个 kCFRunLoopCommonModes 理解成：折磨你改需求的产品经理。<br>kCFRunLoopDefaultMode 就是写android的程序员，UITrackingRunLoopMode是写iOS的程序员。<br>产品经理一个需求，两个程序员必须都要实现这个功能。<br>我们往 CommonModes 里面加入 任意的 source/timer/observer 。<br>就可以想象成是产品经理有新的需求。Android 和 iOS 程序员都要把需求实现。<br>只要加入到了 CommonModes 里面，就相当于添加到了它里面所有的 mode 中（当然，根据各自的情况，可能不仅仅只要默认的两个 mode ）。<br>我们可以通过 NSLog(@”%@”, [NSRunLoop currentRunLoop]) 从打印结果看到 CommonMode 包含了上面的 DefaultMode 和 TrackingRunLoopMode。</p><blockquote><pre><code>common modes = &lt;CFBasicHash 0x7fdaa0d00ae0 [0x1084b57b0]&gt;{type = mutable set, count = 2, entries =&gt;0 : &lt;CFString 0x10939f950 [0x1084b57b0]&gt;{contents = “UITrackingRunLoopMode”}2 : &lt;CFString 0x1084d5b40 [0x1084b57b0]&gt;{contents = “kCFRunLoopDefaultMode”}}</code></pre></blockquote><h4 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h4><p>source 是事件产生的地方（输入源），虽然官方文档在概念上把 source 分为三类：Port-Based Sources，Custom Input Sources，Cocoa Perform Selector Sources。<br>但在源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。<br>source0 是app内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。<br>source1 是基于 mach_ports 的，用于通过内核和其他线程互相发送消息。<br>iOS / OSX 都是基于 Mach 内核，Mach 的对象间的通信是通过消息在两个端口(port)之间传递来完成。<br>很多时候我们的 app 都是处于什么事都不干的状态，在空闲前指定用于唤醒的 mach port 端口，然后在空闲时被 mach_msg() 函数阻塞着并监听唤醒端口， mach_msg() 又会调用 mach_msg_trap() 函数从用户态切换到内核态，这样系统内核就将这个线程挂起，一直停留在 mac_msg_trap 状态。直到另一个线程向内核发送这个端口的 msg 后， trap 状态被唤醒， RunLoop 继续开始干活。<br>其实，总结下来，事件产生的地方就是source(输入源), 运用发消息的机制，让事件可以唤醒休眠的runloop执行。</p><h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>看到 timer 是不是很熟悉？<br>这里的 timer 看起来名字是用C语言的样式，其实是完全等价于我们在OC里面的计时器NSTimer。<br>所以，在平时编程的过程中，我们最开始意识到有 runloop 这回事，就是了使用 NSTimer 的时候。这一点在后面的具体场景应用会详细提到的。<br>另外，这个 CFRunLoopTimerRef，还可以由方法 performSelector:afterDelay:来触发。（因为，本质上 afterDelay, 底层就是启动了 timer ,不然怎么检测具体时间，然后调用回调方法呢。）</p><h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p>看到名字就应该知道这就是一个观察者。它的主要用途就是监听 RunLoop 的状态变化。</p><p>它可以监听RunLoop的7种状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ Run Loop Observer Activities /</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">// 即将进入 loop kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">// 即将处理 timer kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">// 即将处理 source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">// 即将 sleep kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">// 刚被唤醒，退出 sleep kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">// 即将退出 kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">// 全部的活动 kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><h3 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h3><p>苹果官方对于 RunLoop 的创建进行了封装，也就是说我们找不到像alloc 或者 new 这样的方法去手动创建RunLoop。<br>要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数。<br>获取过程大概是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">    static CFMutableDictionaryRef __CFRunLoops = NULL;</span><br><span class="line"></span><br><span class="line">    CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    // 第一次进入时，创建全局 dictionary</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        // 创建可变字典</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable();</span><br><span class="line">        // 先创建主线程的 RunLoop</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        // 主线程的 RunLoop 存进字典中</span><br><span class="line">        CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用 传进来的线程 作 key，获取对应的 RunLoop</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(__CFRunLoops, t);</span><br><span class="line"></span><br><span class="line">    // 如果获取不到，则新建一个，并存入字典</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取主线程的 RunLoop</span><br><span class="line">    CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np());</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 RunLoop</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出, runloop 和 pthread_t （也就是线程）是一一对应的。<br>这样一一对应的关系是保存在一个全局的 dictionary 中的。<br>内部产生 runloop 的机制，与我们 iOS 开发中常用的懒加载很相似。<br>只有到了第一次要使用的时候，才回去创建。当线程销毁的时候，也销毁相应的 runloop。</p><h3 id="runloop-运行逻辑"><a href="#runloop-运行逻辑" class="headerlink" title="runloop 运行逻辑"></a>runloop 运行逻辑</h3><p>runloop 整个的运行逻辑都是在于三个重要的对象如何运作：source （输入源）、timer （定时器）、observer (观察者)。<br>上面的关于 runloop 的相关类里面有过介绍，observer 时刻监听，整个 runloop 的7种 状态的变化。<br>在上面 7 种状态里面，对应着不同的处理。<br>网上的参考逻辑图如下<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop2.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"> //用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"></span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里 runloop 的整个运行逻辑就是一个 do-while 循环。<br>就是我们开篇说的一个——圈。<br>一旦调用了 CFRunLoopRun ,线程就会一直停留在这个循环里面；只有当超时或者被手动停止，函数才会返回，也就是退出了当前的 runloop 。<br>总结成一句话就是：runloop 的运行逻辑就是 do-while 循环下运用观察者模式（或者说是消息发送），根据7种状态的变化，处理事件输入源和定时器。</p><h2 id="苹果官方-RunLoop-实际应用"><a href="#苹果官方-RunLoop-实际应用" class="headerlink" title="苹果官方 RunLoop 实际应用"></a>苹果官方 RunLoop 实际应用</h2><p>RunLoop 作为 iOS app 底层最重要的运行机制，基本运用在一个APP构成的方方方面。 下面请大家跟我一起来看看，说起来那么晕头转向的 RunLoop, 到底可以解释那些 iOS 的常见机制。<br>先来看一道面试题吧（这是我刚开始工作是一个 JAVA面试官问的）：<br>请问 iOS 的NSAutoreleasePool（自动释放池）在什么时候释放？<br>我当时的很纳闷，难道不是到了@autorelease 的 ‘}’（反大括号）就释放了。<br>相对正确的答案应该是：退出 runloop 之前释放。<br>这样就引出了 RunLoop 的第一个应用—— 自动释放池。</p><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>这里的举例分析的是 APP 启动的时候，与主线程同时生成的自动释放池<br>在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0x1, callout = </span><br><span class="line">_wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br></pre></td></tr></table></figure><p>APP 启动之后，苹果在主线程对应的 RunLoop 里面注册了两个 Observer, 其回调都是<br>_wrapRunLoopWithAutoreleasePoolHandler（）。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。<br>与主线程的 RunLoop 运行逻辑类似，在程序中自定义的自动释放池，也是在即将退出 RunLoop 的时候，释放创建的自动释放池。</p><h3 id="NSTimer-定时器"><a href="#NSTimer-定时器" class="headerlink" title="NSTimer (定时器)"></a>NSTimer (定时器)</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。<br>上面有讲到 RunLoop 本身就是一个圈。更进一步说：不断地围着圈跑。<br>这个特性，很像城市里环城巴士。<br>一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。<br>例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。<br>Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。<br>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><h3 id="PerformSelecter…"><a href="#PerformSelecter…" class="headerlink" title="PerformSelecter…"></a>PerformSelecter…</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。<br>这个过程的详细情况可以参考这里。<br>SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。<br>随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。<br>随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h3><p>在当前 RunLoop 的打印结果我们还可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver &gt;&#123;activities = 0xa0,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br></pre></td></tr></table></figure><p>即准备进入睡眠和即将退出 loop 两个时间点，会调用函数更新 UI 界面.<br>当在操作 UI 时，某个需要变化的 UIView/CALayer 就被标记为待处理，然后被提交到一个全局的容器去，再在上面的回调执行时才会被取出来进行绘制和调整。<br>所以如果在一次运行循环中想用如下方法设置一个 view 的两条移动路径是行不通的。因为它会把视图的属性变化汇总起来，直接让 myView 从起点移动到终点了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.myView.frame;</span><br><span class="line">// 先向下移动</span><br><span class="line">frame.origin.y += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 再向右移动</span><br><span class="line">frame.origin.x += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>在仔细分析一下，上面代码的逻辑。<br>第一个动画是想要做到用1秒的时间，Y 值增加200。第二个动画想要实现的是用1秒的时间，X 值增加200.<br>想要实现的先下后右。<br>但是这样是无法实现的。因为，UI的绘制是拿到所有之后，在统一绘制的。</p><h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。如当调用了 dispatch_async(dispatch_get_main_queue(), block)时，主队列会把该 block 放到对应的线程（恰好是主线程）中，主线程的 RunLoop 会被唤醒，从消息中取得这个 block，回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 来执行这个 block：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gcd.png?raw=true" alt=""></p><h2 id="第三方库-RunLoop-的运用"><a href="#第三方库-RunLoop-的运用" class="headerlink" title="第三方库 RunLoop 的运用"></a>第三方库 RunLoop 的运用</h2><h3 id="AFNetWorking-里面的常驻线程"><a href="#AFNetWorking-里面的常驻线程" class="headerlink" title="AFNetWorking 里面的常驻线程"></a>AFNetWorking 里面的常驻线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。</span><br><span class="line">这一点充分体现了：我们控制了runloop ,就是控制了app 的生死。</span><br><span class="line">具体做法是：</span><br><span class="line">            /* 返回一个线程 */</span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">        static NSThread *_networkRequestThread = nil;</span><br><span class="line">        static dispatch_once_t oncePredicate;</span><br><span class="line">        dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">            // 创建一个线程，并在该线程上执行下一个方法</span><br><span class="line">            _networkRequestThread = [[NSThread alloc] initWithTarget:self</span><br><span class="line">                                                            selector:@selector(networkRequestThreadEntryPoint:)</span><br><span class="line">                                                              object:nil];</span><br><span class="line">            // 开启线程</span><br><span class="line">            [_networkRequestThread start];</span><br><span class="line">        &#125;);</span><br><span class="line">        return _networkRequestThread;</span><br><span class="line">    &#125;</span><br><span class="line">/* 在新开的线程中执行的第一个方法 */</span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        // 获取当前线程对应的 RunLoop</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        // 为 RunLoop 添加 source，模式为 DefaultMode</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        // 开始运行 RunLoop</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：<br>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。<br>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。<br>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。<br>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><h2 id="开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"><a href="#开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）" class="headerlink" title="开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"></a>开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）</h2><h3 id="UIImageView-延迟加载图片"><a href="#UIImageView-延迟加载图片" class="headerlink" title="UIImageView 延迟加载图片"></a>UIImageView 延迟加载图片</h3><p>假设我们有一个UITableView，UITableView上面有很多UITableViewCell，UITableViewCell上面有一个UIImageView（你可以想象QQ的聊天页面）。这时候一般我们的需求都是那个UIImageView的图片需要你从网络上下载，并且异步，下载成功之后更新到UIImageView上。<br>实际上这个时候我们就会碰到问题，因为我们的UITab leView是可以任意拖动的，所以如果不更改NSURLConnection的运行模式，那么只要 UItableView 出现滑动，NSURLConnection 所在的DefaultMode 就会退出，切换到 UITrackingRunLoopMode 。<br>给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。<br>解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。<br>为了流畅性，把图片加载延迟</p><h3 id="UITableView-与-NSTimer-冲突"><a href="#UITableView-与-NSTimer-冲突" class="headerlink" title="UITableView 与 NSTimer 冲突"></a>UITableView 与 NSTimer 冲突</h3><p>由于 UItabelView 在滑动的时候，会从当前的 RunLoop 默认的模式 kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 退出，进入到 UITrackingRunLoopMode。<br>这个时候，处于 NSDefaultRunLoopMode 里面的 NSTimer 由于切换了模式造成计时器无法继续运行。<br>可以两个解决方法：（目的就是：即使 mode 切换，计时器依然工作）</p><p>此处参考：<a href="https://www.jianshu.com/p/024782defe60" target="_blank" rel="noopener">iOS下RunLoop的实际应用场景探究</a></p><h2 id="RunLoop-可能的面试套路"><a href="#RunLoop-可能的面试套路" class="headerlink" title="RunLoop 可能的面试套路"></a>RunLoop 可能的面试套路</h2><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop?"></a>什么是RunLoop?</h3><p><a href="http://ios.jobbole.com/85635/" target="_blank" rel="noopener">RunLoop面试题总结</a></p><p>从字面上看:运行循环、跑圈<br>其实它内部就是do-while循环,在这个循环内部不断的处理各种任务(比如Source、Timer、Observer)<br>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop需要手动启动(调用run方法) RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Soure、Timer、Observer,那么就直接退出RunLoop<br>在开发中如何使用RunLoop?什么应用场景?<br>    开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<br>    在子线程中开启一个定时器<br>    在子线程中进行一些长期监控<br>可以控制定时器在特定模式下执行 可以让某些事件(行为、任务)在特定模式下执行 可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RunLoop&quot;&gt;&lt;a href=&quot;#RunLoop&quot; class=&quot;headerlink&quot; title=&quot;RunLoop&quot;&gt;&lt;/a&gt;RunLoop&lt;/h1&gt;&lt;h2 id=&quot;RunLoop-的基本概念&quot;&gt;&lt;a href=&quot;#RunLoop-的基本概念&quot; class
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
    
  </entry>
  
</feed>
