<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-atom.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Blogs" type="application/atom+xml" />






<meta name="description" content="RunLoopRunLoop 的基本概念一、基本概念1、runloop是什么? ———— O   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代">
<meta name="keywords" content="张庚">
<meta property="og:type" content="article">
<meta property="og:title" content="RunLoop-事件循环对象">
<meta property="og:url" content="http://yoursite.com/2018/05/14/RunLoop-事件循环对象/index.html">
<meta property="og:site_name" content="Blogs">
<meta property="og:description" content="RunLoopRunLoop 的基本概念一、基本概念1、runloop是什么? ———— O   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop.png?raw=true">
<meta property="og:image" content="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop2.png">
<meta property="og:image" content="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gcd.png?raw=true">
<meta property="og:updated_time" content="2018-05-14T05:48:11.048Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RunLoop-事件循环对象">
<meta name="twitter:description" content="RunLoopRunLoop 的基本概念一、基本概念1、runloop是什么? ———— O   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代">
<meta name="twitter:image" content="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop.png?raw=true">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/14/RunLoop-事件循环对象/"/>





  <title>RunLoop-事件循环对象 | Blogs</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">张庚</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home 首页"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user 关于"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags 标签"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th 分类"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive 归档"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/14/RunLoop-事件循环对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhanggeng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://i5.tietuku.com/0d972d2b106fc7ea.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RunLoop-事件循环对象</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T10:50:58+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/IOS/" itemprop="url" rel="index">
                    <span itemprop="name">IOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  25
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h1><h2 id="RunLoop-的基本概念"><a href="#RunLoop-的基本概念" class="headerlink" title="RunLoop 的基本概念"></a>RunLoop 的基本概念</h2><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1、runloop是什么-————-O"><a href="#1、runloop是什么-————-O" class="headerlink" title="1、runloop是什么? ———— O"></a>1、runloop是什么? ———— O</h4><p>   用一个字来形容runloop的话，runloop就是————圈。或者说是英文字母——O。这样的形象比<br> 喻，想要说明的是runloop的特性——runloop是一个事件循环对象。一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：do {//接受消息-&gt;等待-&gt;处理}while(message != quit)线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结&gt; 束（比如传入 quit 的<br>消息），函数返回。</p>
<h4 id="没有runloop会怎样？"><a href="#没有runloop会怎样？" class="headerlink" title="没有runloop会怎样？"></a>没有runloop会怎样？</h4><p>上面这样的运行机制通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，<br>比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。<br>实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。<br>如果iOS APP 没有runloop 机制会怎么样呢？<br>如果没有runloop的机制的话，我们的app，从一启动到退出程序时间会很短。<br>更加形象的说，app一启动就死了。<br>所以，runloop 的存在，就是保住app的生命，让app 可以随时待命，处理用户的操作以及其他事件。<br>runloop的重要性就在于：我们控制了runloop ,就是控制了app 的生死</p>
<h2 id="RunLoop-相关类以及构成要素"><a href="#RunLoop-相关类以及构成要素" class="headerlink" title="RunLoop 相关类以及构成要素"></a>RunLoop 相关类以及构成要素</h2><h3 id="runloop-相关类"><a href="#runloop-相关类" class="headerlink" title="runloop 相关类"></a>runloop 相关类</h3><p>在 iOS 中，RunLoop 就是个对象。<br>众所周知，OC 语言是对于 C 的封装。所以呢，会有两个框架，一个是 CoreFoundation，一个是面向对象的 Foundation。<br>全文在解释原理的时候，是直接使用底层 CoreFoundation 的源码解释。</p>
<p>在 CoreFoundation 框架为 CFRunLoopRef 对象，它提供了纯 C 函数的 API，并且这些 API 是线程安全的；<br>而在 Foundation 框架中用 NSRunLoop 对象来表示，它是基于 CFRunLoopRef 的封装，提供的是面向对象的 API，但这些 API 不是线程安全的。<br>CFRunLoopRef 的代码是开源的，我们可以在 这里 或 这里 找到 CFRunLoop.c 来查看 RunLoop 的源码。</p>
<h3 id="构成元素"><a href="#构成元素" class="headerlink" title="构成元素"></a>构成元素</h3><p>在 CoreFoundation 中关于 RunLoop 有 5 个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef</span><br><span class="line">CFRunLoopModeRef</span><br><span class="line">CFRunLoopSourceRef</span><br><span class="line">CFRunLoopTimerRef</span><br><span class="line">CFRunLoopObserverRef</span><br></pre></td></tr></table></figure>
<p>一个Runloop对应一条线程，一个runloop里面可以有多个CFRunLoopModeRef(模式）。<br>同一个时刻，RunLoop只能是在一个mode上面的运行。如果需要切换mode,只能是退出currentMode ,切换到指定的 mode 。<br>每一个mode又可以包含多个 source/timer/observer。不同 mode 里面的子元素，互不影响。</p>
<p>5个类的对应关系大概是：</p>
<p><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop.png?raw=true" alt=""></p>
<p>下面具体介绍这个CFRunLoop里面的4个类。</p>
<h4 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h4><p>官方文档介绍如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A run loop mode is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified.</span><br><span class="line">You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.</span><br><span class="line">You use modes to filter out events from unwanted sources during a particular pass through your run loop.</span><br></pre></td></tr></table></figure></p>
<p>即一个 run loop mode 是若干个 source、timer 和 observer 的集合。它能帮我们过滤掉一些不想要的事件。</p>
<p>即一个 RunLoop 在某个 mode 下运行时，不会接收和处理其他 mode 的事件 </p>
<p>要保持一个 mode 活着，就必须往里面添加至少一个 source、timer 或 observer 。</p>
<p>这一点很容易理解，你想啊，如果一个 mode 里面什么东西都没有，那么他根本就没有活干，那 mode 活着还有什么意思。</p>
<p>苹果公开的 mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode。</p>
<p>前者是默认的模式，程序运行的大多时候都处于该 mode 下，后者是滑动 tableView 或 scrollerView 时为了界面流畅而用的 mode。</p>
<p>还有个 UIInitializationRunLoopMode 是程序启动时进入的 mode，一般用不上。<br>以上，两个公开常用的 mode, 在执行的时候，相互独立，互不干扰。</p>
<p>这样让不同的mode各司其职，对于程序运行的解耦很有好处。<br>但是如果偏偏想要让两个互相不干扰的mode,都做同一件事情可以实现么？<br>可以实现的。苹果爸爸，想到了这一点。<br>CFRunLoop里面有一个伪mode叫做 kCFRunLoopCommonModes，它不是一个真正的 mode，而是若干个 mode 的集合。<br>你可以把这个 kCFRunLoopCommonModes 理解成：折磨你改需求的产品经理。<br>kCFRunLoopDefaultMode 就是写android的程序员，UITrackingRunLoopMode是写iOS的程序员。<br>产品经理一个需求，两个程序员必须都要实现这个功能。<br>我们往 CommonModes 里面加入 任意的 source/timer/observer 。<br>就可以想象成是产品经理有新的需求。Android 和 iOS 程序员都要把需求实现。<br>只要加入到了 CommonModes 里面，就相当于添加到了它里面所有的 mode 中（当然，根据各自的情况，可能不仅仅只要默认的两个 mode ）。<br>我们可以通过 NSLog(@”%@”, [NSRunLoop currentRunLoop]) 从打印结果看到 CommonMode 包含了上面的 DefaultMode 和 TrackingRunLoopMode。</p>
<blockquote>
<pre><code>common modes = &lt;CFBasicHash 0x7fdaa0d00ae0 [0x1084b57b0]&gt;{type = mutable set, count = 2, entries =&gt;0 : &lt;CFString 0x10939f950 [0x1084b57b0]&gt;{contents = “UITrackingRunLoopMode”}
2 : &lt;CFString 0x1084d5b40 [0x1084b57b0]&gt;{contents = “kCFRunLoopDefaultMode”}}
</code></pre></blockquote>
<h4 id="CFRunLoopSourceRef"><a href="#CFRunLoopSourceRef" class="headerlink" title="CFRunLoopSourceRef"></a>CFRunLoopSourceRef</h4><p>source 是事件产生的地方（输入源），虽然官方文档在概念上把 source 分为三类：Port-Based Sources，Custom Input Sources，Cocoa Perform Selector Sources。<br>但在源码中 source 只有两个版本：source0 和 source1，它们的区别在于它们是怎么被标记 (signal) 的。<br>source0 是app内部的消息机制，使用时需要调用 CFRunLoopSourceSignal()来把这个 source 标记为待处理，然后掉用 CFRunLoopWakeUp() 来唤醒 RunLoop，让其处理这个事件。<br>source1 是基于 mach_ports 的，用于通过内核和其他线程互相发送消息。<br>iOS / OSX 都是基于 Mach 内核，Mach 的对象间的通信是通过消息在两个端口(port)之间传递来完成。<br>很多时候我们的 app 都是处于什么事都不干的状态，在空闲前指定用于唤醒的 mach port 端口，然后在空闲时被 mach_msg() 函数阻塞着并监听唤醒端口， mach_msg() 又会调用 mach_msg_trap() 函数从用户态切换到内核态，这样系统内核就将这个线程挂起，一直停留在 mac_msg_trap 状态。直到另一个线程向内核发送这个端口的 msg 后， trap 状态被唤醒， RunLoop 继续开始干活。<br>其实，总结下来，事件产生的地方就是source(输入源), 运用发消息的机制，让事件可以唤醒休眠的runloop执行。</p>
<h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>看到 timer 是不是很熟悉？<br>这里的 timer 看起来名字是用C语言的样式，其实是完全等价于我们在OC里面的计时器NSTimer。<br>所以，在平时编程的过程中，我们最开始意识到有 runloop 这回事，就是了使用 NSTimer 的时候。这一点在后面的具体场景应用会详细提到的。<br>另外，这个 CFRunLoopTimerRef，还可以由方法 performSelector:afterDelay:来触发。（因为，本质上 afterDelay, 底层就是启动了 timer ,不然怎么检测具体时间，然后调用回调方法呢。）</p>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p>看到名字就应该知道这就是一个观察者。它的主要用途就是监听 RunLoop 的状态变化。</p>
<p>它可以监听RunLoop的7种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ Run Loop Observer Activities /</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">// 即将进入 loop kCFRunLoopEntry = (1UL &lt;&lt; 0),</span><br><span class="line">// 即将处理 timer kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1),</span><br><span class="line">// 即将处理 source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),</span><br><span class="line">// 即将 sleep kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),</span><br><span class="line">// 刚被唤醒，退出 sleep kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),</span><br><span class="line">// 即将退出 kCFRunLoopExit = (1UL &lt;&lt; 7),</span><br><span class="line">// 全部的活动 kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><h3 id="获取RunLoop"><a href="#获取RunLoop" class="headerlink" title="获取RunLoop"></a>获取RunLoop</h3><p>苹果官方对于 RunLoop 的创建进行了封装，也就是说我们找不到像alloc 或者 new 这样的方法去手动创建RunLoop。<br>要获取主线程或当前线程对应的 RunLoop，只能通过 CFRunLoopGetMain 或 CFRunLoopGetCurrent 函数。<br>获取过程大概是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 全局的 dictionary, key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">    static CFMutableDictionaryRef __CFRunLoops = NULL;</span><br><span class="line"></span><br><span class="line">    CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    // 第一次进入时，创建全局 dictionary</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        // 创建可变字典</span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable();</span><br><span class="line">        // 先创建主线程的 RunLoop</span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        // 主线程的 RunLoop 存进字典中</span><br><span class="line">        CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用 传进来的线程 作 key，获取对应的 RunLoop</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(__CFRunLoops, t);</span><br><span class="line"></span><br><span class="line">    // 如果获取不到，则新建一个，并存入字典</span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取主线程的 RunLoop</span><br><span class="line">    CFRunLoopRef CFRunLoopGetMain(void) &#123;</span><br><span class="line">    if (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np());</span><br><span class="line">    return __main;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取当前线程的 RunLoop</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出, runloop 和 pthread_t （也就是线程）是一一对应的。<br>这样一一对应的关系是保存在一个全局的 dictionary 中的。<br>内部产生 runloop 的机制，与我们 iOS 开发中常用的懒加载很相似。<br>只有到了第一次要使用的时候，才回去创建。当线程销毁的时候，也销毁相应的 runloop。</p>
<h3 id="runloop-运行逻辑"><a href="#runloop-运行逻辑" class="headerlink" title="runloop 运行逻辑"></a>runloop 运行逻辑</h3><p>runloop 整个的运行逻辑都是在于三个重要的对象如何运作：source （输入源）、timer （定时器）、observer (观察者)。<br>上面的关于 runloop 的相关类里面有过介绍，observer 时刻监听，整个 runloop 的7种 状态的变化。<br>在上面 7 种状态里面，对应着不同的处理。<br>网上的参考逻辑图如下<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/runloop2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"> //用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"></span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里 runloop 的整个运行逻辑就是一个 do-while 循环。<br>就是我们开篇说的一个——圈。<br>一旦调用了 CFRunLoopRun ,线程就会一直停留在这个循环里面；只有当超时或者被手动停止，函数才会返回，也就是退出了当前的 runloop 。<br>总结成一句话就是：runloop 的运行逻辑就是 do-while 循环下运用观察者模式（或者说是消息发送），根据7种状态的变化，处理事件输入源和定时器。</p>
<h2 id="苹果官方-RunLoop-实际应用"><a href="#苹果官方-RunLoop-实际应用" class="headerlink" title="苹果官方 RunLoop 实际应用"></a>苹果官方 RunLoop 实际应用</h2><p>RunLoop 作为 iOS app 底层最重要的运行机制，基本运用在一个APP构成的方方方面。 下面请大家跟我一起来看看，说起来那么晕头转向的 RunLoop, 到底可以解释那些 iOS 的常见机制。<br>先来看一道面试题吧（这是我刚开始工作是一个 JAVA面试官问的）：<br>请问 iOS 的NSAutoreleasePool（自动释放池）在什么时候释放？<br>我当时的很纳闷，难道不是到了@autorelease 的 ‘}’（反大括号）就释放了。<br>相对正确的答案应该是：退出 runloop 之前释放。<br>这样就引出了 RunLoop 的第一个应用—— 自动释放池。</p>
<h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>这里的举例分析的是 APP 启动的时候，与主线程同时生成的自动释放池<br>在打印 [NSRunLoop currentRunLoop] 的结果中我们可以看到与自动释放池相关的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0x1, callout = </span><br><span class="line">_wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">&lt;CFRunLoopObserver&gt;&#123;activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br></pre></td></tr></table></figure>
<p>APP 启动之后，苹果在主线程对应的 RunLoop 里面注册了两个 Observer, 其回调都是<br>_wrapRunLoopWithAutoreleasePoolHandler（）。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。<br>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。<br>与主线程的 RunLoop 运行逻辑类似，在程序中自定义的自动释放池，也是在即将退出 RunLoop 的时候，释放创建的自动释放池。</p>
<h3 id="NSTimer-定时器"><a href="#NSTimer-定时器" class="headerlink" title="NSTimer (定时器)"></a>NSTimer (定时器)</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。<br>上面有讲到 RunLoop 本身就是一个圈。更进一步说：不断地围着圈跑。<br>这个特性，很像城市里环城巴士。<br>一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。<br>例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。<br>Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。<br>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<h3 id="PerformSelecter…"><a href="#PerformSelecter…" class="headerlink" title="PerformSelecter…"></a>PerformSelecter…</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。<br>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。<br>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。<br>这个过程的详细情况可以参考这里。<br>SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。<br>随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。<br>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。<br>随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h3><p>在当前 RunLoop 的打印结果我们还可以看到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoopObserver &gt;&#123;activities = 0xa0,callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br></pre></td></tr></table></figure>
<p>即准备进入睡眠和即将退出 loop 两个时间点，会调用函数更新 UI 界面.<br>当在操作 UI 时，某个需要变化的 UIView/CALayer 就被标记为待处理，然后被提交到一个全局的容器去，再在上面的回调执行时才会被取出来进行绘制和调整。<br>所以如果在一次运行循环中想用如下方法设置一个 view 的两条移动路径是行不通的。因为它会把视图的属性变化汇总起来，直接让 myView 从起点移动到终点了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CGRect frame = self.myView.frame;</span><br><span class="line">// 先向下移动</span><br><span class="line">frame.origin.y += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 再向右移动</span><br><span class="line">frame.origin.x += 200;</span><br><span class="line">[UIView animateWithDuration:1 animations:^&#123;</span><br><span class="line">    self.myView.frame = frame;</span><br><span class="line">    [self.myView setNeedsDisplay];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>在仔细分析一下，上面代码的逻辑。<br>第一个动画是想要做到用1秒的时间，Y 值增加200。第二个动画想要实现的是用1秒的时间，X 值增加200.<br>想要实现的先下后右。<br>但是这样是无法实现的。因为，UI的绘制是拿到所有之后，在统一绘制的。</p>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><p>RunLoop 底层会用到 GCD 的东西，GCD 的某些 API 也用到了 RunLoop。如当调用了 dispatch_async(dispatch_get_main_queue(), block)时，主队列会把该 block 放到对应的线程（恰好是主线程）中，主线程的 RunLoop 会被唤醒，从消息中取得这个 block，回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 来执行这个 block：<br><img src="https://github.com/zhanggengwei/BlogImages/blob/master/Image/gcd.png?raw=true" alt=""></p>
<h2 id="第三方库-RunLoop-的运用"><a href="#第三方库-RunLoop-的运用" class="headerlink" title="第三方库 RunLoop 的运用"></a>第三方库 RunLoop 的运用</h2><h3 id="AFNetWorking-里面的常驻线程"><a href="#AFNetWorking-里面的常驻线程" class="headerlink" title="AFNetWorking 里面的常驻线程"></a>AFNetWorking 里面的常驻线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子线程默认是完成任务后结束。当要经常使用子线程，每次开启子线程比较耗性能。此时可以开启子线程的 RunLoop，保持 RunLoop 运行，则使子线程保持不死。AFNetworking 基于 NSURLConnection 时正是这样做的，希望在后台线程能保持活着，从而能接收到 delegate 的回调。</span><br><span class="line">这一点充分体现了：我们控制了runloop ,就是控制了app 的生死。</span><br><span class="line">具体做法是：</span><br><span class="line">            /* 返回一个线程 */</span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">        static NSThread *_networkRequestThread = nil;</span><br><span class="line">        static dispatch_once_t oncePredicate;</span><br><span class="line">        dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">            // 创建一个线程，并在该线程上执行下一个方法</span><br><span class="line">            _networkRequestThread = [[NSThread alloc] initWithTarget:self</span><br><span class="line">                                                            selector:@selector(networkRequestThreadEntryPoint:)</span><br><span class="line">                                                              object:nil];</span><br><span class="line">            // 开启线程</span><br><span class="line">            [_networkRequestThread start];</span><br><span class="line">        &#125;);</span><br><span class="line">        return _networkRequestThread;</span><br><span class="line">    &#125;</span><br><span class="line">/* 在新开的线程中执行的第一个方法 */</span><br><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        // 获取当前线程对应的 RunLoop</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        // 为 RunLoop 添加 source，模式为 DefaultMode</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        // 开始运行 RunLoop</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 RunLoop 启动前必须设置一个 mode，而 mode 要存在则至少需要一个 source / timer。所以上面的做法是为 RunLoop 的 DefaultMode 添加一个 NSMachPort 对象，虽然消息是可以通过 NSMachPort 对象发送到 loop 内，但这里添加的 port 只是为了 RunLoop 一直不退出，而没有发送什么消息。当然我们也可以添加一个超长启动时间的 timer 来既保持 RunLoop 不退出也不占用资源。</p>
<h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：<br>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。<br>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。<br>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。<br>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。<br>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p>
<h2 id="开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"><a href="#开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）" class="headerlink" title="开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"></a>开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）</h2><h3 id="UIImageView-延迟加载图片"><a href="#UIImageView-延迟加载图片" class="headerlink" title="UIImageView 延迟加载图片"></a>UIImageView 延迟加载图片</h3><p>假设我们有一个UITableView，UITableView上面有很多UITableViewCell，UITableViewCell上面有一个UIImageView（你可以想象QQ的聊天页面）。这时候一般我们的需求都是那个UIImageView的图片需要你从网络上下载，并且异步，下载成功之后更新到UIImageView上。<br>实际上这个时候我们就会碰到问题，因为我们的UITab leView是可以任意拖动的，所以如果不更改NSURLConnection的运行模式，那么只要 UItableView 出现滑动，NSURLConnection 所在的DefaultMode 就会退出，切换到 UITrackingRunLoopMode 。<br>给 UIImageView 设置图片可能耗时不少，如果此时要滑动 tableView 等则可能影响到界面的流畅。<br>解决是：使用 performSelector:withObject:afterDelay:inModes: 方法，将设置图片的方法放到 DefaultMode 中执行。<br>为了流畅性，把图片加载延迟</p>
<h3 id="UITableView-与-NSTimer-冲突"><a href="#UITableView-与-NSTimer-冲突" class="headerlink" title="UITableView 与 NSTimer 冲突"></a>UITableView 与 NSTimer 冲突</h3><p>由于 UItabelView 在滑动的时候，会从当前的 RunLoop 默认的模式 kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 退出，进入到 UITrackingRunLoopMode。<br>这个时候，处于 NSDefaultRunLoopMode 里面的 NSTimer 由于切换了模式造成计时器无法继续运行。<br>可以两个解决方法：（目的就是：即使 mode 切换，计时器依然工作）</p>
<p>此处参考：<a href="https://www.jianshu.com/p/024782defe60" target="_blank" rel="noopener">iOS下RunLoop的实际应用场景探究</a></p>
<h2 id="RunLoop-可能的面试套路"><a href="#RunLoop-可能的面试套路" class="headerlink" title="RunLoop 可能的面试套路"></a>RunLoop 可能的面试套路</h2><h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop?"></a>什么是RunLoop?</h3><p><a href="http://ios.jobbole.com/85635/" target="_blank" rel="noopener">RunLoop面试题总结</a></p>
<p>从字面上看:运行循环、跑圈<br>其实它内部就是do-while循环,在这个循环内部不断的处理各种任务(比如Source、Timer、Observer)<br>一个线程对应一个RunLoop,主线程的RunLoop默认已经启动,子线程的RunLoop需要手动启动(调用run方法) RunLoop只能选择一个Mode启动,如果当前Mode中没有任何Soure、Timer、Observer,那么就直接退出RunLoop<br>在开发中如何使用RunLoop?什么应用场景?<br>    开启一个常驻线程(让一个子线程不进入消亡状态,等待其他线程发来消息,处理其他事件)<br>    在子线程中开启一个定时器<br>    在子线程中进行一些长期监控<br>可以控制定时器在特定模式下执行 可以让某些事件(行为、任务)在特定模式下执行 可以添加Observer监听RunLoop的状态,比如监听点击事件的处理(在所有点击事件之前做一些事情)</p>

      
    </div>
    
    
    
    
      <div>
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2018/05/14/RunLoop-事件循环对象/">RunLoop-事件循环对象</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 zhanggeng 的个人博客">zhanggeng</a></p>
  <p><span>发布时间:</span>2018年05月14日 - 10:05</p>
  <p><span>最后更新:</span>2018年05月14日 - 13:05</p>
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>

      </div>
    
    

    

    
    
    <div>
      
      <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/14/position与index-z/" rel="next" title="position">
                <i class="fa fa-chevron-left"></i> position
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/14/linux文件复用/" rel="prev" title="linux文件复用">
                linux文件复用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://i5.tietuku.com/0d972d2b106fc7ea.jpg"
                alt="zhanggeng" />
            
              <p class="site-author-name" itemprop="name">zhanggeng</p>
              <p class="site-description motion-element" itemprop="description">张庚个人博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RunLoop"><span class="nav-number">1.</span> <span class="nav-text">RunLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-的基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">RunLoop 的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基本概念"><span class="nav-number">1.1.1.</span> <span class="nav-text">一、基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、runloop是什么-————-O"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、runloop是什么? ———— O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#没有runloop会怎样？"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">没有runloop会怎样？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-相关类以及构成要素"><span class="nav-number">1.2.</span> <span class="nav-text">RunLoop 相关类以及构成要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop-相关类"><span class="nav-number">1.2.1.</span> <span class="nav-text">runloop 相关类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构成元素"><span class="nav-number">1.2.2.</span> <span class="nav-text">构成元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopModeRef"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">CFRunLoopModeRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopSourceRef"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">CFRunLoopSourceRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopTimerRef"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">CFRunLoopTimerRef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CFRunLoopObserverRef"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">CFRunLoopObserverRef</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop的运行逻辑"><span class="nav-number">1.3.</span> <span class="nav-text">RunLoop的运行逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取RunLoop"><span class="nav-number">1.3.1.</span> <span class="nav-text">获取RunLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop-运行逻辑"><span class="nav-number">1.3.2.</span> <span class="nav-text">runloop 运行逻辑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#苹果官方-RunLoop-实际应用"><span class="nav-number">1.4.</span> <span class="nav-text">苹果官方 RunLoop 实际应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#自动释放池"><span class="nav-number">1.4.1.</span> <span class="nav-text">自动释放池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSTimer-定时器"><span class="nav-number">1.4.2.</span> <span class="nav-text">NSTimer (定时器)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PerformSelecter…"><span class="nav-number">1.4.3.</span> <span class="nav-text">PerformSelecter…</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件响应"><span class="nav-number">1.4.4.</span> <span class="nav-text">事件响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#手势识别"><span class="nav-number">1.4.5.</span> <span class="nav-text">手势识别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UI更新"><span class="nav-number">1.4.6.</span> <span class="nav-text">UI更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD"><span class="nav-number">1.4.7.</span> <span class="nav-text">GCD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三方库-RunLoop-的运用"><span class="nav-number">1.5.</span> <span class="nav-text">第三方库 RunLoop 的运用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFNetWorking-里面的常驻线程"><span class="nav-number">1.5.1.</span> <span class="nav-text">AFNetWorking 里面的常驻线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AsyncDisplayKit"><span class="nav-number">1.5.2.</span> <span class="nav-text">AsyncDisplayKit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开发中常见-RunLoop-使用-（如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）"><span class="nav-number">1.6.</span> <span class="nav-text">开发中常见 RunLoop 使用 （如果对原理不感兴趣，可以直接跳到末尾看实际使用，这样有的放矢，阅读效率更高）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UIImageView-延迟加载图片"><span class="nav-number">1.6.1.</span> <span class="nav-text">UIImageView 延迟加载图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UITableView-与-NSTimer-冲突"><span class="nav-number">1.6.2.</span> <span class="nav-text">UITableView 与 NSTimer 冲突</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RunLoop-可能的面试套路"><span class="nav-number">1.7.</span> <span class="nav-text">RunLoop 可能的面试套路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是RunLoop"><span class="nav-number">1.7.1.</span> <span class="nav-text">什么是RunLoop?</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <!--<div class="copyright">&copy; 
   <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhanggeng</span> 

  

</div>-->

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



-->
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-balance-scale"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhanggeng</span>
</div>

<div class="busuanzi-count">
    <script async="" src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户： <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数： <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
    <!-- 博客字数统计 -->
    <span class="site-pv">
      <i class="fa fa-pencil"></i>
      博客全站共： <span class="post-count">27.8k</span> 字
    </span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<!-- <script type="text/javascript" src="/js/src/love.js"></script> -->
